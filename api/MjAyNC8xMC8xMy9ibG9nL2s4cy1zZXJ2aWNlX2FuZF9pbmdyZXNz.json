{"title":"[Kubernetes In Action] Service & Ingress","date":"2024-10-14T05:00:00.000Z","date_formatted":{"ll":"Oct 14, 2024","L":"10/14/2024","MM-DD":"10-14"},"author":"Qingfeng Zhang","thumbnail":"images/photo/R0005812.JPG","link":"2024/10/13/blog/k8s-service_and_ingress","categories":["Kubernetes"],"updated":"2025-05-07T15:33:02.905Z","content":"<h1 id=\"service\">Service<a title=\"#service\" href=\"#service\"></a></h1>\n<h2 id=\"k8s中的service是什么\">K8s中的Service是什么<a title=\"#k8s中的service是什么\" href=\"#k8s中的service是什么\"></a></h2>\n<p>先给出Service的定义：<strong>K8s中的service是一种为一组功能相同的pod提供单一不变的接入点的资源</strong>。</p>\n<p>创建一个Service后，它的ip和port不会改变，K8s会为Service创建一个cluster ip来让集群内部的其他pod访问，也可以直接通过Service Name进行访问，K8s的DNS服务会将域名<code>service-name.namespace.svc.cluster.local</code>解析为cluster ip。</p>\n<h2 id=\"为什么需要service\">为什么需要Service<a title=\"#为什么需要service\" href=\"#为什么需要service\"></a></h2>\n<p>当我们在K8s中创建一些pod之后，这些pod可能是为集群内其他pod提供服务，也可能是为集群外部的请求提供服务。</p>\n<p>按照一般的方法，如果想要访问一个服务，就需要知道它的ip和服务暴露的port，但是这种方式在K8s中不太适用，因为：</p>\n<ol>\n<li>K8s中的pod可能会因为各种原因删除、新建或者重启，而每次新创建的pod会分配新的ip，并且ip分配是在pod启动之前执行的，这导致无法准确知道所需要访问的pod的准确ip</li>\n<li>可能会有多个pod同时提供一个服务，每个pod都有自己的ip，对于服务的使用者来说，不应该考虑使用哪一个pod，负载均衡的问题应该由K8s来解决</li>\n</ol>\n<p>为了解决以上的问题，就需要<strong>Service</strong>这种K8s的资源类型。</p>\n<h2 id=\"如何使用service\">如何使用Service<a title=\"#如何使用service\" href=\"#如何使用service\"></a></h2>\n<ol>\n<li>可以使用<code>kubectl expose</code>命令创建Service，例如：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">Create a service <span class=\"keyword\">for</span> a replicated nginx, <span class=\"built_in\">which</span> serves on port 80 and connects to the containers on port 8000</span></span><br><span class=\"line\">kubectl expose rc nginx --port=80 --target-port=8000</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>通过编写yaml配置然后更新到K8s集群上，本质和<code>kubectl expose</code>是一样的，例如：</li>\n</ol>\n<figure class=\"highlight yaml\"><figcaption><span>yaml</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">kubia</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">80</span></span><br><span class=\"line\">    <span class=\"attr\">targetport:</span> <span class=\"number\">8080</span></span><br><span class=\"line\">  <span class=\"string\">selector</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">kubia</span></span><br></pre></td></tr></table></figure>\n<p>这将会创建一个名字为kubia的Service资源，这个Service会监听80端口的请求，并把请求转发到具有标签选择器app=kubia的pod的8080端口上。</p>\n<p>Service创建之后K8s会为其分配一个cluster ip，可以用于访问Service。</p>\n<blockquote>\n<p>Service会自动配置负载均衡策略，如果想要指定访问某个pod的服务，可以配置Service的<code>sessionAffinity: ClientIP</code>，这会将来自同一个ClientIP的请求都转发到同一个pod</p>\n</blockquote>\n<h2 id=\"service的服务发现\">Service的服务发现<a title=\"#service的服务发现\" href=\"#service的服务发现\"></a></h2>\n<p>我们为pod创建Service之后，就可以通过稳定的Service的IP来访问我们的多个pod提供的服务了，但是其他的pod又是怎么知道Service的IP和端口的呢？</p>\n<p>K8s提供了两种Service服务发现的方式：</p>\n<ol>\n<li>通过环境变量</li>\n</ol>\n<p>在pod创建完成刚开始运行的时候，K8s会创建一系列的环境变量指向现在的Service，可以在pod中查看ENV来列出这些环境变量。</p>\n<p>这种方式的问题在于环境变量的创建是基于当前存在的Service，如果Service的创建在pod创建之后，这个pod的环境变量中就没有新创建的Service的信息。</p>\n<ol start=\"2\">\n<li>通过DNS</li>\n</ol>\n<p>一般在K8s集群的kube-system这个namespace下会有名为core-DNS的pod，集群中的pod可以配置为使用其作为DNS（K8s可以修改pod的/etc/resolve.conf来实现），这样在pod上的DNS查询都会被coreDNS服务响应。</p>\n<blockquote>\n<p>这就使得在集群内部可以使用全限定域名（FQDN）<code>service-name.namespace.svc.cluster.local</code>来访问K8s的Service，并且在同一个namespace中，只需要使用Service name访问即可</p>\n</blockquote>\n<h2 id=\"暴露service到集群外部\">暴露Service到集群外部<a title=\"#暴露service到集群外部\" href=\"#暴露service到集群外部\"></a></h2>\n<p>很多时候我们不只是想在集群内部访问pod上的服务，某些服务需要提供给集群外部的人来访问，对此K8s提供了几种方式：</p>\n<ol>\n<li>NodePort类型的Service</li>\n</ol>\n<p>可以设置Service中spec的type为NodePort来创建此类型的Service，这会让K8s在每个Node上都保留一个相同的port用于Service的访问，因为Node的IP是外部可以访问的</p>\n<ol start=\"2\">\n<li>LoadBalance类型的Service</li>\n</ol>\n<p>LoadBalance是NodePort的扩展，在使用NodePort的时候虽然从不同的Node的IP+port访问的是同一个Service，但是Node会有多个，我们只能选择其中一个，因此LoadBalance就用于解决这个问题，通过负载均衡器（云厂商提供）提供一个外部可访问的External-IP来访问我们的Service，并实现Node的负载均衡</p>\n<ol start=\"3\">\n<li>Ingress</li>\n</ol>\n<p>另一种K8s资源类型，可以通过一个IP公开多个Service</p>\n<p>Ingress运行在HTTP层（网络协议第七层），相比于Service（网络协议第四层）可提供的功能更多</p>\n<blockquote>\n<p>Service的类型：ClusterIP、NodePort、LoadBalance、ExternalIP</p>\n</blockquote>\n<h1 id=\"endpoint\">Endpoint<a title=\"#endpoint\" href=\"#endpoint\"></a></h1>\n<p>Service配置中spec的selector会定义连接到哪些pod，但是实际上访问Service的时候不会把请求直接重定向到pod中</p>\n<p>实际上K8s会把selector中对应的pod的IP和port存储在Endpoint资源中，当我们请求服务时，kube proxy会选择其中一个IP和port，并将请求重定向到该pod中</p>\n<p>当我们意识到Endpoint是Service和Pod中间的另一种资源，用于进行解耦，我们就可以手动配置这个Service的Endpoint，例如不在Service中配置Selector，并手动修改其对应的Endpoint，实现使用K8s的Service将请求重定向到任意一个IP和port</p>\n<h1 id=\"ingress\">Ingress<a title=\"#ingress\" href=\"#ingress\"></a></h1>\n<h2 id=\"k8s中的ingress是什么\">K8s中的Ingress是什么<a title=\"#k8s中的ingress是什么\" href=\"#k8s中的ingress是什么\"></a></h2>\n<p>前面也提到Ingress是一种可以向集群外部公开Service的K8s资源类型</p>\n<h2 id=\"为什么需要ingress\">为什么需要Ingress<a title=\"#为什么需要ingress\" href=\"#为什么需要ingress\"></a></h2>\n<p>如果只是想在集群外部访问集群内的服务，使用LoadBalance类型的Service是不是已经够了？但是如果我们有多个Service需要暴露出来呢，这样每个Service都要有自己的负载均衡器，以及External-IP，而Ingress只需要一个公网IP就可以为多个Service提供访问，并且因为是在第七层，可以接收HTTP请求，从而可以根据不同的URL参数访问不同的Service</p>\n<p>Ingress的使用相对比较简单，后面还是通过Service-Endpoint-Pod的顺序，在Ingress的配置中也可以加上TLS来使用HTTPS</p>\n","prev":{"title":"签名与证书","link":"2025/01/06/blog/sign_cert"},"next":{"title":"Java学习小记","link":"2020/11/04/blog/Java_learning"},"plink":"https://qfzack.github.io/2024/10/13/blog/k8s-service_and_ingress/","toc":[{"id":"service","title":"Service","index":"1","children":[{"id":"k8s中的service是什么","title":"K8s中的Service是什么","index":"1.1"},{"id":"为什么需要service","title":"为什么需要Service","index":"1.2"},{"id":"如何使用service","title":"如何使用Service","index":"1.3"},{"id":"service的服务发现","title":"Service的服务发现","index":"1.4"},{"id":"暴露service到集群外部","title":"暴露Service到集群外部","index":"1.5"}]},{"id":"endpoint","title":"Endpoint","index":"2"},{"id":"ingress","title":"Ingress","index":"3","children":[{"id":"k8s中的ingress是什么","title":"K8s中的Ingress是什么","index":"3.1"},{"id":"为什么需要ingress","title":"为什么需要Ingress","index":"3.2"}]}],"reading_time":"1567 words in 10 min"}