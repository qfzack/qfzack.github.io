{"title":"学习笔记：Java中的注解与反射(一)","date":"2020-03-09T05:00:00.000Z","date_formatted":{"ll":"Mar 9, 2020","L":"03/09/2020","MM-DD":"03-09"},"author":"Qingfeng Zhang","link":"2020/03/08/blog/Java_annotation","categories":["Java"],"updated":"2025-09-14T16:04:23.642Z","content":"<h1 id=\"一、注解\">一、注解<a title=\"#一、注解\" href=\"#一、注解\"></a></h1>\n<h2 id=\"1.注解的概念\">1.注解的概念<a title=\"#1.注解的概念\" href=\"#1.注解的概念\"></a></h2>\n<p>注解是Java提供的一种原程序中的元素关联任何信息和任何元数据的途径和方法。</p>\n<h2 id=\"2.java中的常见注解\">2.Java中的常见注解<a title=\"#2.java中的常见注解\" href=\"#2.java中的常见注解\"></a></h2>\n<h3 id=\"2.1-jdk自带的注解\">2.1 JDK自带的注解<a title=\"#2.1-jdk自带的注解\" href=\"#2.1-jdk自带的注解\"></a></h3>\n<ul>\n<li><code>@Override</code>：当对接口中的方法进行实现时，需要覆盖；</li>\n<li><code>@Deprecated</code>：表示方法已经过时不再使用；</li>\n<li><code>@Suppvisewarnings</code>：如果想要使用已标注<code>@Deprecated</code>的方法，可以加上注解<code>@Suppvisewarnings(&quot;deprecated&quot;)</code>;</li>\n</ul>\n<h2 id=\"3.注解的分类\">3.注解的分类<a title=\"#3.注解的分类\" href=\"#3.注解的分类\"></a></h2>\n<p><strong>按照运行机制分类：</strong></p>\n<ul>\n<li>源码注解：注解只在源码中存在，编译成.class文件就不存在了；</li>\n<li>编译时注解：在源码和.class文件中都存在，如上述的JDK自带注解；</li>\n<li>运行时注解：在运行阶段还会起作用，升值会影响运行时逻辑，如<code>@Autowired</code>；</li>\n</ul>\n<p><strong>按照来源分类：</strong></p>\n<ul>\n<li>来自JDK的注解；</li>\n<li>来自第三方的注解；</li>\n<li>自定义的注解；</li>\n</ul>\n<p><strong>元注解：</strong></p>\n<ul>\n<li>注解的注解；</li>\n</ul>\n<h2 id=\"4.自定义注解\">4.自定义注解<a title=\"#4.自定义注解\" href=\"#4.自定义注解\"></a></h2>\n<h3 id=\"4.1-自定义注解的语法要求\">4.1 自定义注解的语法要求<a title=\"#4.1-自定义注解的语法要求\" href=\"#4.1-自定义注解的语法要求\"></a></h3>\n<p>使用<code>@interface</code>关键字定义注解，以下是定义注解的示例，类定义的上面是<strong>元注解</strong> ：<br>\n第一行<code>@Target</code>标明注解的作用域是方法和类，可以使用的参数有：构造方法的声明，字段声明，局部变量的声明，方法声明，包声明，参数声明，类接口；<br>\n第二行<code>@Retention</code>表明注解的生命周期，如在源码显示编译时丢弃，编译时记录到calss运行时忽略，运行时存在可通过反射读取；<br>\n第三行<code>@Inherited</code>表明允许子类继承，但是不能继承接口和方法的，只能继承类的注解；<br>\n第四行<code>@Documented</code>表明生成javadoc时会包含注解；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span>  </span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span>  </span><br><span class=\"line\"><span class=\"meta\">@Inherited</span>  </span><br><span class=\"line\"><span class=\"meta\">@Documented</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Description&#123;  </span><br><span class=\"line\">    String <span class=\"title function_\">desc</span><span class=\"params\">()</span>;  <span class=\"comment\">//成员以无参无异常的方式声明；  </span></span><br><span class=\"line\">    </span><br><span class=\"line\">    String <span class=\"title function_\">author</span><span class=\"params\">()</span>;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">age</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"number\">18</span>;  <span class=\"comment\">//可以使用default为成员指定默认值；  </span></span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>注解类中成员的类型是受限的，合法的类型包括原始类型和String,Class,Annotation,Enumeration；<br>\n如果注解只有一个成员，则成员名必须取名为<code>value()</code>，在使用时可以忽略成员名和赋值号<code>=</code>；<br>\n注解类可以没有成员，没有成员的注解称为标识注解；</p>\n<h3 id=\"4.2-自定义注解的使用\">4.2 自定义注解的使用<a title=\"#4.2-自定义注解的使用\" href=\"#4.2-自定义注解的使用\"></a></h3>\n<p>使用注解的语法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@&lt;注解名&gt;(&lt;成员名<span class=\"number\">1</span>&gt;=&lt;成员值<span class=\"number\">1</span>&gt;,&lt;成员名<span class=\"number\">2</span>&gt;=&lt;成员值<span class=\"number\">2</span>&gt;,...)  </span><br></pre></td></tr></table></figure>\n<p>举个栗子如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Description(desc=&quot;IAmEyeColor&quot;,author=&quot;Zack&quot;,age=18)</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">eyeColor</span><span class=\"params\">()</span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Blue&quot;</span>;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>其中<code>@Description</code>是上面自定义的注解；</p>\n<h3 id=\"4.3-注解的解析\">4.3 注解的解析<a title=\"#4.3-注解的解析\" href=\"#4.3-注解的解析\"></a></h3>\n<p>解析注解是通过反射获取类、函数或成员上的<strong>运行时</strong> 注解信息，从而实现动态控制程序运行的逻辑；<br>\n<strong>找到类上的注解：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Class</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> Class.forName(<span class=\"string\">&quot;com.zhangqf.test.Child&quot;</span>);  <span class=\"comment\">//加载一个类；  </span></span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"variable\">isExist</span> <span class=\"operator\">=</span> c.isAnnotationPresent(Description.class);  </span><br><span class=\"line\"><span class=\"keyword\">if</span>(isExist)&#123;  </span><br><span class=\"line\">    <span class=\"type\">Description</span> <span class=\"variable\">d</span> <span class=\"operator\">=</span> (Description)c.getAnnotation(Description.class);  </span><br><span class=\"line\">    System.out.println(d.value());  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p><strong>找到方法上的注解：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Method[] ms = c.getMethods();  </span><br><span class=\"line\"><span class=\"keyword\">for</span>(Method m: ms)&#123;  </span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">isMExist</span> <span class=\"operator\">=</span> m.isAnnotationPresent(Description.class);  </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(isMExist)&#123;  </span><br><span class=\"line\">        <span class=\"type\">Description</span> <span class=\"variable\">d</span> <span class=\"operator\">=</span> (Description)m.getAnnotation(Description.class);  </span><br><span class=\"line\">        System.out.println(d.value());  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p><strong>注解本身只是起到标记的作用，注解需要反射机制，根据注解的标记去调用注解解释器执行行为。</strong></p>\n<h1 id=\"二、反射\">二、反射<a title=\"#二、反射\" href=\"#二、反射\"></a></h1>\n<h2 id=\"1.class类的使用\">1.Class类的使用<a title=\"#1.class类的使用\" href=\"#1.class类的使用\"></a></h2>\n<p>“在面向对象的世界里，万事万物皆对象”，在Java中静态的成员和基本数据类型不是对象(有封装类)，而每一个类都是java.lang.Class的实例对象;</p>\n<ul>\n<li><strong>使用反射实例化一个类有三种方式:</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Food</span> <span class=\"variable\">food</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Food</span>();  <span class=\"comment\">//Food是一个自定义的类；  </span></span><br><span class=\"line\"><span class=\"comment\">//方式1：类.class  </span></span><br><span class=\"line\"><span class=\"type\">Class</span> <span class=\"variable\">c1</span> <span class=\"operator\">=</span> Food.class;    </span><br><span class=\"line\"><span class=\"comment\">//方式2：对象.getClass()  </span></span><br><span class=\"line\"><span class=\"type\">Class</span> <span class=\"variable\">c2</span> <span class=\"operator\">=</span> food.getClass();  </span><br><span class=\"line\"><span class=\"comment\">//方式3：Class.forName(&quot;name&quot;)  </span></span><br><span class=\"line\"><span class=\"type\">Class</span> <span class=\"variable\">c3</span> <span class=\"operator\">=</span> Class.forName(<span class=\"string\">&quot;com.zhangqf.Food&quot;</span>);  </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">//通过类的类型创建该类的实例对象  </span></span><br><span class=\"line\"><span class=\"comment\">//方式一：使用newInstance()方法  </span></span><br><span class=\"line\"><span class=\"type\">Food</span> <span class=\"variable\">food</span> <span class=\"operator\">=</span> (Food)c3.newInstance();  </span><br><span class=\"line\"><span class=\"comment\">//方式二：先调用构造器，再使用newInstance()方法  </span></span><br><span class=\"line\"><span class=\"type\">Object</span> <span class=\"variable\">food2</span> <span class=\"operator\">=</span> c3.constructor().newInstance();  </span><br></pre></td></tr></table></figure>\n<p>以上的c1，c2，c3表示了food类的类类型(class type)，且一个类只能是Class类的一个实例对象，所以c1，c2，c3相等；</p>\n<ul>\n<li><strong>获取类的信息，包括类的成员函数和成员变量：</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClassUtil</span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getClassMessage</span><span class=\"params\">(Object obj)</span>&#123;  </span><br><span class=\"line\">        <span class=\"comment\">//先获取对象的类的类类型  </span></span><br><span class=\"line\">        <span class=\"type\">Class</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> obj.getClass();  <span class=\"comment\">//传递的是哪个子类的对象，c就是该子类的类类型  </span></span><br><span class=\"line\">        <span class=\"comment\">//获取类名称  </span></span><br><span class=\"line\">        System.out.println(c.getName());  </span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">//成员方法是Method的对象，getMethods()获取类的public方法，包括父类继承来的  </span></span><br><span class=\"line\">        <span class=\"comment\">//getDeclaredMethods()是获取该类自己声明的方法，不问权限  </span></span><br><span class=\"line\">        Method[] ms = c.getMethods();  <span class=\"comment\">//c.getDeclaredMethods();  </span></span><br><span class=\"line\">        <span class=\"comment\">//获取对象中方法的返回值类型的类类型、方法名称和参数类型  </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;ms.length;i++&gt;)&#123;  </span><br><span class=\"line\">            <span class=\"type\">Class</span> <span class=\"variable\">returnType</span> <span class=\"operator\">=</span> ms[i].getReturnType();  <span class=\"comment\">//方法返回值的类类型  </span></span><br><span class=\"line\">            System.out.println(returnType.getName());  <span class=\"comment\">//返回值类类型的名称  </span></span><br><span class=\"line\">            System.out.println(ms[i].getName());  <span class=\"comment\">//方法的名称  </span></span><br><span class=\"line\">            Class[] paramType = ms[i].getParameterTypes();  <span class=\"comment\">//得到参数列表的类型的类类型，如int.class  </span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(Class class1: paramType)&#123;  </span><br><span class=\"line\">                System.out.println(class1.getName());  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">//获取类对象中方法的成员变量信息  </span></span><br><span class=\"line\">        <span class=\"comment\">//在java.lang.reflect.Field中封装了关于成员变量的操作  </span></span><br><span class=\"line\">        <span class=\"comment\">//getFields()获取所有public的成员变量的信息；  </span></span><br><span class=\"line\">        Field[] fs = c.getDeclaredFields();  <span class=\"comment\">//获取该类声明的所有成员变量信息；  </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(Fiels field: fs)&#123;  </span><br><span class=\"line\">            <span class=\"type\">Class</span> <span class=\"variable\">fieldType</span> <span class=\"operator\">=</span> field.getType();  <span class=\"comment\">//获取成员变量类型的类类型  </span></span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">typeName</span> <span class=\"operator\">=</span> fieldType.getName();  <span class=\"comment\">//获取成员变量的名称  </span></span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">//获取对象的构造函数的信息，构造函数也是对象  </span></span><br><span class=\"line\">        <span class=\"comment\">//在java.lang.Constructor中封装了构造函数的信息  </span></span><br><span class=\"line\">        <span class=\"comment\">//getConstructors()获取所有的public的构造函数  </span></span><br><span class=\"line\">        Constructor[] cs = c.getDeclaredConstructors();  <span class=\"comment\">//获取所有的构造方法，构造函数均是自己声明的；  </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(Constructor constructor: cs)&#123;  </span><br><span class=\"line\">            System.out.println(constructor.getName());  </span><br><span class=\"line\">            <span class=\"comment\">//获取构造函数的参数列表，得到的是参数列表的类类型  </span></span><br><span class=\"line\">            Class[] paramTypes = constructor.getParameterTypes();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<h2 id=\"2.方法的反射执行\">2.方法的反射执行<a title=\"#2.方法的反射执行\" href=\"#2.方法的反射执行\"></a></h2>\n<p>通过方法的名称和方法的参数列表才能唯一决定某个方法；<br>\n举个栗子，有以下的类定义，类中有两个同名的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class A&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">print</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b)</span>&#123;  </span><br><span class=\"line\">        System.out.println(a+<span class=\"string\">&quot;,&quot;</span>+b);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">print</span><span class=\"params\">(String s1,String s2)</span>&#123;  </span><br><span class=\"line\">        System.out.println(s1+s2);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>如果要获取<code>print(int a,int b)</code>方法，首先要获取类的类类型，从而获取类的信息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取A类的类类型  </span></span><br><span class=\"line\"><span class=\"type\">A</span> <span class=\"variable\">a1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">A</span>();  </span><br><span class=\"line\"><span class=\"type\">Class</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> a1.getClass();  </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">//获取方法、名称和参数列表  </span></span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">//参数可以写为(&quot;print&quot;,new Class[]&#123;int.class,int.class&#125;)  </span></span><br><span class=\"line\">    <span class=\"type\">Method</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> c.getMethod(<span class=\"string\">&quot;print&quot;</span>,<span class=\"type\">int</span>.class,<span class=\"type\">int</span>.class);  <span class=\"comment\">//方法可能不存在，因此需要处理异常，  </span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//方法的反射操作是使用对象m来进行方法的调用与a1.print()效果相同  </span></span><br><span class=\"line\">    <span class=\"comment\">//与方法的返回值相同，若没有则为null  </span></span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">o</span> <span class=\"operator\">=</span> m.invoke(a1,<span class=\"number\">123</span>,<span class=\"number\">456</span>);  <span class=\"comment\">//参数可以写为(a1,new Object[]&#123;123,456&#125;)  </span></span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(Exception e)&#123;  </span><br><span class=\"line\">    e.printStackTrace();  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<h2 id=\"3.动态类加载\">3.动态类加载<a title=\"#3.动态类加载\" href=\"#3.动态类加载\"></a></h2>\n<p><code>new</code>创建对象是静态加载类，在编译的时候就需要加载所有可能用到的类，比如在<code>main</code>方法中写到了类的使用，就必须保证该类已被加载，否则报错，如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class Office&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"string\">&quot;Word&quot;</span>.equals(args[<span class=\"number\">0</span>]))&#123;  </span><br><span class=\"line\">            <span class=\"type\">Word</span> <span class=\"variable\">w</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Word</span>();  </span><br><span class=\"line\">            w.start();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"string\">&quot;Excel&quot;</span>.equals(args[<span class=\"number\">0</span>]))&#123;  </span><br><span class=\"line\">            <span class=\"type\">Excel</span> <span class=\"variable\">e</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Excel</span>();  </span><br><span class=\"line\">            e.start();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>如果Word类或Excel类未定义或未加载，则会报错，如果只想使用其中一个类，静态加载类无法做到；<br>\n通过<strong>动态加载类</strong> 可以解决这个问题：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Office</span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;  </span><br><span class=\"line\">            <span class=\"comment\">//动态加载类，在运行时刻加载  </span></span><br><span class=\"line\">            <span class=\"type\">Class</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> Class.forName(args[<span class=\"number\">0</span>]);  </span><br><span class=\"line\">            <span class=\"comment\">//通过类类型创建对象  </span></span><br><span class=\"line\">            <span class=\"type\">OfficeAble</span> <span class=\"variable\">oa</span> <span class=\"operator\">=</span> (OfficeAble)c.newInstance();  <span class=\"comment\">//需要另外定义OfficeAble  </span></span><br><span class=\"line\">            oa.start()  </span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span>&#123;  </span><br><span class=\"line\">            e.printStackTrace();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>定义<code>OfficeAble</code>为一个接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">OfficeAble</span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">start</span><span class=\"params\">()</span>;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>此时如果想使用<code>Word</code>类，只需要让<code>Word</code>类实现<code>OfficeAble</code>接口，定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Word</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">OfficeAble</span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">start</span><span class=\"params\">()</span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;word...start...&quot;</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<h2 id=\"4.通过反射认识泛型的本质\">4.通过反射认识泛型的本质<a title=\"#4.通过反射认识泛型的本质\" href=\"#4.通过反射认识泛型的本质\"></a></h2>\n<p>集合的泛型是为了防止错误输入，如：<br>\n<code>ArrayList list1 = new ArrayList()</code><br>\n可以放入任何类型的数据，但是<br>\n<code>ArrayList&lt;String&gt; list2 = new ArrayList&lt;String&gt;()</code><br>\n就只能放入字符串String类型的数据，但是<strong>list1.class()与list2.class()相等</strong><br>\n，而反射的操作都是在编译之后的操作，这说明编译之后集合的泛型是<strong>去泛型化的</strong><br>\n，因此Java中集合的泛型只在编译阶段有效，为了防止错误输入，绕过编译之后就无效了；<br>\n可以<strong>通过方法的反射来绕过编译</strong> ：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Class</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> list2.getClass();  </span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;  </span><br><span class=\"line\">    <span class=\"type\">Method</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> c.getMethod(<span class=\"string\">&quot;add&quot;</span>,Object.class);  </span><br><span class=\"line\">    c.invoke(list2,<span class=\"number\">10</span>);  <span class=\"comment\">//list2本来只能放字符串  </span></span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(Exception e)&#123;  </span><br><span class=\"line\">    e.printStackTrace();  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>上面的例子中可以通过反射绕过泛型向list2中添加整数类型的值，但是for-each遍历会有类型转换错误；<br>\n总之记住：反射、Class、Method和Field的操作都是绕过编译在运行时执行的。</p>\n","prev":{"title":"Java-BFS与DFS","link":"2020/03/08/blog/Java_DFS_Backtrack"},"next":{"title":"记录我的第一个Java项目","link":"2020/02/12/blog/Java_Project"},"plink":"https://qfzack.github.io/2020/03/08/blog/Java_annotation/","toc":[{"id":"一、注解","title":"一、注解","index":"1","children":[{"id":"1.注解的概念","title":"1.注解的概念","index":"1.1"},{"id":"2.java中的常见注解","title":"2.Java中的常见注解","index":"1.2","children":[{"id":"2.1-jdk自带的注解","title":"2.1 JDK自带的注解","index":"1.2.1"}]},{"id":"3.注解的分类","title":"3.注解的分类","index":"1.3"},{"id":"4.自定义注解","title":"4.自定义注解","index":"1.4","children":[{"id":"4.1-自定义注解的语法要求","title":"4.1 自定义注解的语法要求","index":"1.4.1"},{"id":"4.2-自定义注解的使用","title":"4.2 自定义注解的使用","index":"1.4.2"},{"id":"4.3-注解的解析","title":"4.3 注解的解析","index":"1.4.3"}]}]},{"id":"二、反射","title":"二、反射","index":"2","children":[{"id":"1.class类的使用","title":"1.Class类的使用","index":"2.1"},{"id":"2.方法的反射执行","title":"2.方法的反射执行","index":"2.2"},{"id":"3.动态类加载","title":"3.动态类加载","index":"2.3"},{"id":"4.通过反射认识泛型的本质","title":"4.通过反射认识泛型的本质","index":"2.4"}]}],"reading_time":"2333 words in 16 min"}