{"title":"Java学习小记","date":"2020-11-05T05:00:00.000Z","date_formatted":{"ll":"Nov 5, 2020","L":"11/05/2020","MM-DD":"11-05"},"author":"Qingfeng Zhang","link":"2020/11/04/blog/Java_learning","categories":["Java"],"updated":"2025-05-07T15:33:02.904Z","content":"<h1 id=\"1.-对java中泛型的理解\">1. 对java中泛型的理解<a title=\"#1.-对java中泛型的理解\" href=\"#1.-对java中泛型的理解\"></a></h1>\n<p>刚开始学习java，发现java建立的数组不能够增加或是删除元素，非常的不方便，而java中的list可以，在Java中新建一个整型list可以通过：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; l = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;()  </span><br></pre></td></tr></table></figure>\n<p>得到，可以指定类型为Integer或String等，也可以不指定；<br>\n<strong>问题：首先是这个类型的指定不理解，其次这像是一个建立对象实例化的语法，但是怎么前面是list，后面却是ArrayList</strong> ；<br>\n<strong>对于第一个问题</strong> ，查了资料发现这是<strong>泛型</strong> ，那泛型有什么作用？关于这个看了一些资料进行总结：<br>\njava程序开发是面向对象，所以会有各种各样类型的对象，而对象需要用容器来装，像数组、ArrayList、HashMap都是容器；<br>\n对于整型数组，一开始就指定了所装的对象类型：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>[] L;  </span><br></pre></td></tr></table></figure>\n<p>对于集合类型的容器，如ArrayList和HashMap，可以装入任何类型的对象，因此这些容器设计为装Object类型的对象，即根类，但是在取出对象的时候需要进行强制类型转换，转换成实际的类型，这样很不安全，因此就需要泛型，在这个问题里，泛型可以指定容器装入对象的类型,以我的理解（当然这只是一个片面且不一定正确的理解），如果建立一个整型list：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;()  </span><br></pre></td></tr></table></figure>\n<p>那么这个result只能添加整型数据，并且如果将Integer换成String后只能添加字符串，如果运行<code>result.add(1)</code>会报错；<br>\n关于上面的Integer和int又是一个问题了，简单来说Integer是java为int提供的封装类，即Integer是一个对象，而int只是一个基本数据类型，<strong>基本类型不能作为泛型的参数</strong><br>\n，泛型指定的类型必须是<strong>引用数据类型</strong>(类，接口，数组)，因此不能用<strong>基本数据类型</strong>(内置数据类型)int；<br>\n比如，如果定义了一个类phone，指定list泛型的数据类型为phone，那么list就只能装phone对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;phone&gt; P = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();  </span><br><span class=\"line\">P.add(<span class=\"keyword\">new</span> <span class=\"title class_\">phone</span>(<span class=\"string\">&quot;xiaomi&quot;</span>));  </span><br></pre></td></tr></table></figure>\n<p>泛型的应用场景有泛型类，泛型接口，泛型方法；</p>\n<p><strong>对于第二个问题</strong><br>\n，这里的List是一个接口，而ArrayList是对List接口实现的类，因此ArrayList的方法包含List的方法，但是接口是不能实例化的，这里是一个接口类型的引用指向了一个实现给接口的对象；<br>\n举一个例子，先定义一个接口Talking，里面的方法say默认为静态方法，需要重载，然后定义一个people类来实现Talking接口，在people类里对say方法进行重载，然后用people实例化一个对象P，并声明一个Talking接口类型的引用指向这个对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Talking</span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">say</span><span class=\"params\">()</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">People</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Talking</span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">say</span><span class=\"params\">()</span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Hello!&quot;</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">interface_test</span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;  </span><br><span class=\"line\">        <span class=\"type\">Talking</span> <span class=\"variable\">P</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">People</span>();  </span><br><span class=\"line\">        P.say();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>实际中遇到过的问题：当我想用一个整数数组来初始化HashSet，错误的代码为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;Integer&gt; set = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;(Arrays.asList(nums));  </span><br></pre></td></tr></table></figure>\n<p>问题在于这里的nums是一个int数组，是基本类型，<code>Arrays.asList(nums)</code>的数据类型为<code>java.util.Arrays$ArrayList</code>，因此不能用来初始化一个HashSet，对于ArrayList也是一样，如果想要把基本类型int的数组转换为HashSet或是ArrayList，可以通过：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;Integer&gt; set = Arrays.stream(A).boxed().collect(Collectors.toSet());  </span><br></pre></td></tr></table></figure>\n<p>或是循环逐个添加；</p>\n<h1 id=\"2.-collections接口与map接口\">2. Collections接口与Map接口<a title=\"#2.-collections接口与map接口\" href=\"#2.-collections接口与map接口\"></a></h1>\n<p>最近在做题的时候遇到了一个小问题，在判断一堆数里是否存在一个值时，会使用ArrayList的contains方法，导致的问题就是会超时，找了一圈才发现用HashSet的contains方法更好（注意ArrayList可以按索引删除），然后在定义HashSet对象的时候又蒙了，这些数据结构的接口与类之间到底是什么关系，于是就想整理一下；<br>\nCollections是一个基本的集合接口，List、Set、Queue接口继承了Collections接口；List是一个有序的Collections，因此能够控制元素插入的位置，并且通过索引来访问元素，允许元素重复；Set接口与Collections完全相同，只是Set存储一组无序的对象，且不保存重复的元素；List按索引查找的效率高，插入和删除的效率低，因为有序会对导致其他元素的位置改变，而Set检索的效率低，删除和插入的效率高，因为Set无序；<br>\n1.对于<strong>List</strong> 接口的实现类：<strong>ArrayList</strong> 、LinkedList；<br>\n2.对于<strong>Set</strong> 接口的实现类：<strong>HashSet</strong> 、TreeSet、LinkedHashSet；<br>\n3.Queue接口可以使用LinkedList类；<br>\nMap也是一个接口，Map中的每一个元素都包含键对象和值对象，<strong>Map</strong> 接口的实现类有：HashMap、HashTable、TreeMap；<br>\n每个接口都包含一些方法，每个实现类都实现了其接口的方法，并且都具有自身的特点，因此，对于不同的问题应该选择合适的类建立对象；</p>\n<h1 id=\"3.-lambda表达式\">3. Lambda表达式<a title=\"#3.-lambda表达式\" href=\"#3.-lambda表达式\"></a></h1>\n<p>Lambda表达式是Java 8的一个重要的新特性，也可称为闭包，Lambda表达式允许把函数作为一个方法的参数，主要还是因为遇到了这样一个问题：<br>\n有一个经典的问题：找出一些数种最小的k个数，这里不详解这个问题的解题方法，直接排序是可以的，但是对于数据量巨大的情况不合适，其中有一个方法就是维护一个容量为k的大根堆，大根堆会将最大的数放在树的根节点，每次遇到比根节点小的数就更新根节点为小的数，而Java种可以使用PriorityQueue来实现大根堆或小根堆，且默认是小根堆，如果要使用大根堆则要自定义比较器，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PriorityQueue&lt;Integer&gt; maxHeap = <span class=\"keyword\">new</span> <span class=\"title class_\">PriorityQueue</span>&lt;&gt;(k,<span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>&lt;Integer&gt;()&#123;  </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(Integer o1,Integer o2)</span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> o2-o1;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;);  </span><br></pre></td></tr></table></figure>\n<p>当然这样写没问题，但是也可以使用Lambda表达式来实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PriorityQueue&lt;Integer&gt; maxHeap = <span class=\"keyword\">new</span> <span class=\"title class_\">PriorityQueue</span>&lt;&gt;(k,(o1,o2)-&gt;&#123;<span class=\"keyword\">return</span> o2-o1;&#125;)  </span><br></pre></td></tr></table></figure>\n<p>非常简洁，因为这个小问题，所以我想看下Lambda表达式；<br>\n<strong>Lambda表达式的语法：</strong><br>\n<code>(parameters) -&gt; expression</code><br>\n或者：<br>\n<code>(parameters) -&gt; &#123;statements;&#125;</code><br>\nLambda的参数不需要声明类型，编译器会自动返回表达式的值，或是使用<code>&#123;&#125;</code>指明需要返回的值，如：<br>\n<code>(a, b) -&gt; a*b;</code><br>\n<code>(a, b) -&gt; &#123;return a*b&#125;;</code><br>\n<strong>Lambda表达式的变量：</strong><br>\n1.lambda表达式只能引用标记final的外层局部变量，不能在表达式内修改外部的变量值；<br>\n2.如果引用的变量没有声明为final，该变量之后不能修改值（隐性final）；<br>\n3.lambda表达式内不能使用与局部变量同名的参数；<br>\n对于一个接口，如果只包含一个抽象方法，那么它就是一个<strong>函数式接口</strong><br>\n，对于函数式接口可以通过Lambda表达式来创建该接口的对象，下面是一个从内部类到Lambda表达式的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">test</span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">//1.静态内部类  </span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">cat1</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Animal</span>&#123;  </span><br><span class=\"line\">        <span class=\"meta\">@Override</span>  </span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">call</span><span class=\"params\">()</span>&#123;  </span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Hello!&quot;</span>);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;  </span><br><span class=\"line\">        <span class=\"type\">Animal</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">cat1</span>();  <span class=\"comment\">//静态内部类的使用  </span></span><br><span class=\"line\">        a.call();  </span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">//2.局部内部类  </span></span><br><span class=\"line\">        <span class=\"keyword\">class</span> <span class=\"title class_\">cat2</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Animal</span>&#123;  </span><br><span class=\"line\">            <span class=\"meta\">@Override</span>  </span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">call</span><span class=\"params\">()</span>&#123;  </span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Hello!&quot;</span>);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        a = <span class=\"keyword\">new</span> <span class=\"title class_\">cat2</span>();  <span class=\"comment\">//局部内部类的使用  </span></span><br><span class=\"line\">        a.call();  </span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">//3.匿名内部类，没有类名称，借助接口或父类  </span></span><br><span class=\"line\">        a = <span class=\"keyword\">new</span> <span class=\"title class_\">Animal</span>()&#123;  </span><br><span class=\"line\">            <span class=\"meta\">@Override</span>  </span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">call</span><span class=\"params\">()</span>&#123;  </span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Hello!&quot;</span>);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;;  </span><br><span class=\"line\">        a.call();  </span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">//4.Lambda表达式  </span></span><br><span class=\"line\">        a = () -&gt; &#123;  </span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Hello!&quot;</span>);  </span><br><span class=\"line\">        &#125;;  </span><br><span class=\"line\">        a.call();  </span><br><span class=\"line\">    </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Animal</span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">call</span><span class=\"params\">()</span>;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<h1 id=\"4.-hashmap与hashcode：\">4. HashMap与HashCode：<a title=\"#4.-hashmap与hashcode：\" href=\"#4.-hashmap与hashcode：\"></a></h1>\n<p>刚刚遇到了一个小问题：使用HashMap时想使用数组作为key，但是内容相同的数组并不能通过containsKey()查找出来，因此想知道HashMap是怎么判断key相等的？还有哪些数据类型作为key可以直接通过内容判断是否存在对应的key？哪些又不行？<br>\n简单来说，JVM每new一个Object，都会根据其hashcode将这个Object放到Hash表中，查找的时候直接依据它的hashcode查找以提高效率，对于hashcode有以下三个约定：</p>\n<ol>\n<li>在一个应用程序运行期间，假设一个对象的equals方法做比較所用到的信息没有被改动的话。则对该对象调用hashCode方法多次，它必须始终如一地返回同一个整数。</li>\n<li>假设两个对象依据equals(Object o)方法是相等的，则调用这两个对象中任一对象的hashCode方法必须产生同样的整数结果。</li>\n<li>假设两个对象依据equals(Object o)方法是不相等的。则调用这两个对象中任一个对象的hashCode方法。不要求产生不同的整数结果。但假设能不同，则可能提高散列表的性能。</li>\n</ol>\n<p>注意两个hashcode相同的对象不一定相等；<br>\nHashMap中比较两个key是否相等时会使用hashcode()和equals()方法，即先比较key的hashcode()，相等的话再比较equals()，所以如果要在HashMap放入自定义的key类，一般需要重写该类的hashcode()和equals()(Object)方法，以保证相同的比较逻辑；<br>\nint[]对象的hashcode方法是直接使用Object类的，计算hashcode的结果与引用有关，因此两个内容相同但是引用不同的数组有不同的hashcode；<br>\nString的hashcode是由内容计算的，因此内容相等的字符串hashcode也相同，但是也存在内容不同hashcode相同的情况；<br>\n<code>==</code>符号对于基本数据类型是比较值，对于引用数据类型是比较引用(地址)；<br>\n<code>equals()</code>在Object中比较的是引用（没有被重写的话则是比较引用），不用于基本数据类型的比较，<strong>在String类中被重写，比较的是值</strong> ；<br>\n（对于基本数据类型的包装类，<code>==</code>比较的是地址，<code>equals()</code>比较的是值）<br>\n综上可以知道，当使用基本数据类型的包装类作为HashMap的key时，每次比较(计算hashcode()和equals())的是变量的值，对于引用类型，如果没有重写hashcode()和equals()的话，默认比较引用(地址)；</p>\n<h1 id=\"5.-笔记碎片\">5. 笔记碎片<a title=\"#5.-笔记碎片\" href=\"#5.-笔记碎片\"></a></h1>\n<h2 id=\"001-列表list的常用方法：\">001 列表List的常用方法：<a title=\"#001-列表list的常用方法：\" href=\"#001-列表list的常用方法：\"></a></h2>\n<p>Java集合有两个体系：Collection和Map；<br>\nCollection主要有三个接口：List(列表)、Set(集)、Queue(队列)；<br>\nList中主要有ArrayList和LinkedList两个实现类；<br>\nList集合是有序的，ArrayList底层通过数组实现，可以动态扩容，而LinkedList底层通过链表实现，也可以不断增加节点实现扩容；<br>\n在这里记录一下<strong>List的常用方法：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; l = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();  <span class=\"comment\">//初始化list  </span></span><br><span class=\"line\">    </span><br><span class=\"line\">l.add(<span class=\"number\">12</span>);  <span class=\"comment\">//向list添加元素  </span></span><br><span class=\"line\">l.set(<span class=\"number\">0</span>,<span class=\"number\">13</span>);  <span class=\"comment\">//修改指定位置的元素值  </span></span><br><span class=\"line\">l.get(<span class=\"number\">0</span>);  <span class=\"comment\">//获取指定位置的元素值  </span></span><br><span class=\"line\">l.isEmpty();  <span class=\"comment\">//判断是否为空  </span></span><br><span class=\"line\">l.remove(<span class=\"number\">0</span>);  <span class=\"comment\">//删除指定位置的值  </span></span><br><span class=\"line\">l.clear();  <span class=\"comment\">//清空list  </span></span><br></pre></td></tr></table></figure>\n<p>关于remove()方法一直有疑惑，怎么知道里面的参数是索引还是元素值？网上的一些博客很好地“避免”了这个问题，因为看到的所有List的泛型都是String，几乎不谈Integer。其实这个也很容易理解，举个例子就知道了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; l = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();  </span><br><span class=\"line\">    </span><br><span class=\"line\">l.add(<span class=\"number\">9</span>);  <span class=\"comment\">//[9]  </span></span><br><span class=\"line\">l.add(<span class=\"number\">8</span>);  <span class=\"comment\">//[9,8]  </span></span><br><span class=\"line\">l.add(<span class=\"number\">7</span>);  <span class=\"comment\">//[9,8,7]  </span></span><br><span class=\"line\">    </span><br><span class=\"line\">l.remove(<span class=\"number\">0</span>);  <span class=\"comment\">//[8,7]  </span></span><br><span class=\"line\">l.remove((Integer)<span class=\"number\">7</span>);  <span class=\"comment\">//[8]  </span></span><br></pre></td></tr></table></figure>\n<p>这样就一目了然了，因为List内的元素是Integer类型，只有将整数转为Integer包装类型，才能按照元素值删除，否则就是将整数当作索引；</p>\n<h2 id=\"002-字符串string的基本方法与字符类型char：\">002 字符串String的基本方法与字符类型Char：<a title=\"#002-字符串string的基本方法与字符类型char：\" href=\"#002-字符串string的基本方法与字符类型char：\"></a></h2>\n<p>在Java中，char是一个基本数据类型，在定义的时候用的是单引号<code>''</code>，但是String是一个类，属于引用数据类型，定义的时候用的是双引号<code>&quot;&quot;</code>;</p>\n<ul>\n<li>String的常用方法：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;zhangqingfeng&quot;</span>;  </span><br><span class=\"line\"><span class=\"type\">char</span>[] L = name.toCharArray();  <span class=\"comment\">//转换为字符数组；  </span></span><br><span class=\"line\">String[] S = name.split(<span class=\"string\">&quot;n&quot;</span>);  <span class=\"comment\">//按*字符串*&quot;n&quot;来分割字符串；  </span></span><br><span class=\"line\">System.out.println(name.length());  <span class=\"comment\">//字符串的长度；  </span></span><br><span class=\"line\">System.out.println(name.charAt(<span class=\"number\">2</span>));  <span class=\"comment\">//获取索引为1的字符，返回char类型；  </span></span><br><span class=\"line\">System.out.println(name.indexOf(<span class=\"string\">&quot;q&quot;</span>));  <span class=\"comment\">//获取*字符串*&quot;q&quot;的位置；  </span></span><br><span class=\"line\">System.out.println(name.subString(<span class=\"number\">0</span>,<span class=\"number\">5</span>));  <span class=\"comment\">//获取字符串的一个子串；  </span></span><br><span class=\"line\">System.out.println(name.contains(<span class=\"string\">&quot;z&quot;</span>));  <span class=\"comment\">//判断字符串中是否包含另一个字符串；  </span></span><br><span class=\"line\">System.out.println(name.replaceAll(<span class=\"string\">&quot;z&quot;</span>,<span class=\"string\">&quot;Z&quot;</span>));  <span class=\"comment\">//替换字符串中的所有指定子串；  </span></span><br><span class=\"line\">System.out.println(name.replaceFirst(<span class=\"string\">&quot;z&quot;</span>,<span class=\"string\">&quot;Z&quot;</span>)); <span class=\"comment\">//替换字符串中第一次出现的子串；  </span></span><br></pre></td></tr></table></figure>\n<p>经常将长度为1的字符串和单个字符弄混，其实这两个是不一样；</p>\n<ul>\n<li>将char转换成String：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">S</span> <span class=\"operator\">=</span> String.valueOf(<span class=\"string\">&#x27;z&#x27;</span>);  <span class=\"comment\">//效率比较高；  </span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">S</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span> + <span class=\"string\">&#x27;z&#x27;</span>;  <span class=\"comment\">//简单但是效率低；  </span></span><br></pre></td></tr></table></figure>\n<p>将长度为1的String转为char直接使用类型转换<code>(char)&quot;z&quot;</code>就行；</p>\n<h2 id=\"003-list排序与初始化：\">003 list排序与初始化：<a title=\"#003-list排序与初始化：\" href=\"#003-list排序与初始化：\"></a></h2>\n<p>对一个<strong>二维数组</strong> M按照<strong>第一列进行排序</strong> ：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Arrays.sort(M,Comparator.comparingInt(x -&gt; x[<span class=\"number\">0</span>]));  </span><br></pre></td></tr></table></figure>\n<p><strong>创建一个list并用变量l和r初始化</strong> ，可以使用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; L = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();  </span><br></pre></td></tr></table></figure>\n<p>先创建一个list然后<code>L.add(l);``L.add(r);</code>,这样比较麻烦，可以更简单点：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; L = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(Arrays.asList(l,r))  </span><br></pre></td></tr></table></figure>\n<p>或是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; L = Arrays.asList(l,r)  </span><br></pre></td></tr></table></figure>\n<h2 id=\"004-关于二维数组与二维list：\">004 关于二维数组与二维list：<a title=\"#004-关于二维数组与二维list：\" href=\"#004-关于二维数组与二维list：\"></a></h2>\n<p>有个题目要求返回一个二维的数组<code>int[][] result</code>，但是数组不方便，只好用list，一开始是<code>List&lt;List&lt;Integer&gt;&gt; result</code>，即先建立一个二维的list，但最后想转换为二维数组时不知道怎么转;<br>\n其实可以建立一个存放一维数组的list，即<code>List&lt;int[]&gt; result</code>，其存放的一维数组长度为2，这样的话就可以方便的将其转换为二维数组：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result.toArray(<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[result.size()][<span class=\"number\">2</span>]);  </span><br></pre></td></tr></table></figure>\n<p>里面的参数可以理解为构造一个int类型与result维度一致的空数组。</p>\n<h2 id=\"005-字符串与字符(数组)的转换\">005 字符串与字符(数组)的转换<a title=\"#005-字符串与字符(数组)的转换\" href=\"#005-字符串与字符(数组)的转换\"></a></h2>\n<p><strong>字符串- &gt;字符串(字符)数组：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;zhang,qing,feng&quot;</span>;  </span><br><span class=\"line\">String[] arr1 = name.split(<span class=\"string\">&quot;,&quot;</span>);  <span class=\"comment\">//转换成字符串数组  </span></span><br><span class=\"line\"><span class=\"type\">char</span>[] arr2 = name.toCharArray(name);  <span class=\"comment\">//转换成字符数组  </span></span><br></pre></td></tr></table></figure>\n<p><strong>字符数组- &gt;字符串：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span>[] arr = [<span class=\"string\">&#x27;z&#x27;</span>,<span class=\"string\">&#x27;h&#x27;</span>,<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;n&#x27;</span>,<span class=\"string\">&#x27;g&#x27;</span>];  </span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">name1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(arr);  <span class=\"comment\">//方法一  </span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">name2</span> <span class=\"operator\">=</span> String.valueOf(arr);  <span class=\"comment\">//方法二  </span></span><br></pre></td></tr></table></figure>\n<p><strong>字符串- &gt;字符</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;z&quot;</span>;  </span><br><span class=\"line\"><span class=\"type\">char</span> <span class=\"variable\">ch</span> <span class=\"operator\">=</span> name.charAt(<span class=\"number\">0</span>);  </span><br></pre></td></tr></table></figure>\n<p><strong>字符- &gt;字符串</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> <span class=\"variable\">ch</span> <span class=\"operator\">=</span> <span class=\"string\">&#x27;z&#x27;</span>;  </span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> Character.toString(ch);  <span class=\"comment\">//方法一  </span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s2</span> <span class=\"operator\">=</span> String.valueOf(ch);  <span class=\"comment\">//方法二  </span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s3</span> <span class=\"operator\">=</span> ch+<span class=\"string\">&quot;&quot;</span>;  <span class=\"comment\">//方法三  </span></span><br></pre></td></tr></table></figure>\n<h2 id=\"006-自定义排序方法对list进行排序：\">006 自定义排序方法对list进行排序：<a title=\"#006-自定义排序方法对list进行排序：\" href=\"#006-自定义排序方法对list进行排序：\"></a></h2>\n<p>在NO.937中有一种奇怪的字符串比较方式，还要按照这种方式排序；<br>\n对于数组的排序是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Arrays.sort(arr);  </span><br></pre></td></tr></table></figure>\n<p>对于集合的排序是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Collections.sort(arr2);  </span><br></pre></td></tr></table></figure>\n<p>后者有更复杂的排序，可以对Comparator接口的compare方法进行重写，如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Collections.sort(l1,<span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>&lt;String&gt;()&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(String s1, String s2)</span>&#123;  </span><br><span class=\"line\">        <span class=\"type\">int</span> i=s1.indexOf(<span class=\"string\">&quot; &quot;</span>), j=s2.indexOf(<span class=\"string\">&quot; &quot;</span>);  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s1.substring(i).compareTo(s2.substring(j))==<span class=\"number\">0</span>)&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> s1.substring(<span class=\"number\">0</span>,i).compareTo(s2.substring(<span class=\"number\">0</span>,j));  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> s1.substring(i).compareTo(s2.substring(j));  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;);  </span><br></pre></td></tr></table></figure>\n<p>根据compare返回值判断s1和s2的大小关系，如果返回正数表示s1大，负数表示s2大，0表示相等；</p>\n<h2 id=\"007-关于java中list与int[]互转的坑：\">007 关于Java中list与int[]互转的坑：<a title=\"#007-关于java中list与int[]互转的坑：\" href=\"#007-关于java中list与int[]互转的坑：\"></a></h2>\n<p>以下代码是建立一个整数list并将其转换为int[],结果报错说</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; l = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();  </span><br><span class=\"line\">l.add(<span class=\"number\">1</span>);  </span><br><span class=\"line\">l.add(<span class=\"number\">3</span>);  </span><br><span class=\"line\">l.add(<span class=\"number\">4</span>);  </span><br><span class=\"line\">System.out.println(l.toArray(<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[l.size()]));  </span><br></pre></td></tr></table></figure>\n<p>结果报错说没有<code>toArray(int[])</code>方法，但是换成String却可以，问题在于后面的<code>int[]</code>，要写成<code>Integer[]</code>;<br>\n对于一个<code>List&lt;int[]&gt; L</code>要将其转为<code>int[][]</code>只要<code>L.toArray(new int[L.size()][])</code>即可，所以问题就在于不能用基本数据类型，换成包装类就行；<br>\n<strong>将list 转为int[]:</strong><br>\n<code>int[] arr = list.stream().mapToInt(Integer::valueOf).toArray();</code><br>\n<strong>将int[]转为list :</strong><br>\n<code>List&lt;Integer&gt; list = Arrays.Stream(arr).boxed().collect(Collectors.toList());</code><br>\n<strong>将int[]转为Integer[]</strong><br>\n<code>Integer[] I = Arrays.stream(arr).boxed().toArray(Integer[]::new);</code><br>\n<strong>将Integer[]转为int[]</strong><br>\n<code>int[] arr = Arrays.Stream(I).mapToInt(Integer::valueOf).toArray();</code></p>\n<h2 id=\"008-java中的栈与队列：\">008 Java中的栈与队列：<a title=\"#008-java中的栈与队列：\" href=\"#008-java中的栈与队列：\"></a></h2>\n<h3 id=\"栈的实现与方法：\">栈的实现与方法：<a title=\"#栈的实现与方法：\" href=\"#栈的实现与方法：\"></a></h3>\n<p>栈可以通过Java本身的集合类型Stack实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Stack</span> <span class=\"variable\">stack1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>();  </span><br><span class=\"line\">Stack&lt;Integer&gt; stack2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;&gt;();  </span><br></pre></td></tr></table></figure>\n<p><strong>栈的常用方法如下：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stack.empty()  <span class=\"comment\">//判断栈是否为空  </span></span><br><span class=\"line\">stack.peek()  <span class=\"comment\">//获取栈顶值（不出栈）  </span></span><br><span class=\"line\">stack.push(value)  <span class=\"comment\">//入栈  </span></span><br><span class=\"line\">stack.pop()  <span class=\"comment\">//出栈  </span></span><br></pre></td></tr></table></figure>\n<h3 id=\"队列的实现与方法：\">队列的实现与方法：<a title=\"#队列的实现与方法：\" href=\"#队列的实现与方法：\"></a></h3>\n<p>Java给出了队列的接口Queue，但是没有具体的实现类，可以使用LinkedList实现类，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Queue&lt;Integer&gt; que = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();  </span><br></pre></td></tr></table></figure>\n<p><strong>队列的常用方法：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">que.isEmpty()  <span class=\"comment\">//判断队列是否为空  </span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 获取队头元素  </span></span><br><span class=\"line\">que.peek()  <span class=\"comment\">//队空返回null  </span></span><br><span class=\"line\">que.element()  <span class=\"comment\">//队空抛出异常  </span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 元素入队  </span></span><br><span class=\"line\">que.offer(value)  <span class=\"comment\">//队满返回false  </span></span><br><span class=\"line\">que.add(value)  <span class=\"comment\">//队满抛出异常  </span></span><br><span class=\"line\">que.put(value)  <span class=\"comment\">//队满阻塞  </span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 元素出队  </span></span><br><span class=\"line\">que.poll()  <span class=\"comment\">//队空返回null  </span></span><br><span class=\"line\">que.remove()  <span class=\"comment\">//队空抛出异常  </span></span><br><span class=\"line\">que.take()  <span class=\"comment\">//队空阻塞  </span></span><br></pre></td></tr></table></figure>\n<p>此外，队列还包括双端队列，双端队可以使用LinkedList实现类和ArrayDeque实现类；LinkedList是大小可变的链表双端队列，允许null值，ArrayDeque是大小可变的数组双端队列，不允许null值：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Deque&lt;Integer&gt; deq = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();  </span><br><span class=\"line\">Deque&lt;Integer&gt; deq = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayDeque</span>&lt;&gt;(<span class=\"number\">4</span>);  </span><br></pre></td></tr></table></figure>\n<p><strong>双端队列的常用方法：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deq.peekFirst()  <span class=\"comment\">//获取队头元素  </span></span><br><span class=\"line\">deq.peekLast()  <span class=\"comment\">//获取队尾元素  </span></span><br><span class=\"line\">    </span><br><span class=\"line\">deq.offerFirst()  <span class=\"comment\">//从队头入队  </span></span><br><span class=\"line\">deq.offerLast()  <span class=\"comment\">//从队尾入队  </span></span><br><span class=\"line\">    </span><br><span class=\"line\">deq.pollFirst()  <span class=\"comment\">//队头元素出队  </span></span><br><span class=\"line\">deq.pollLast()  <span class=\"comment\">//队尾元素出队  </span></span><br></pre></td></tr></table></figure>\n<p>还可以使用一般队列的方法，此外队列还有BlockingQueue，以上的所列出的只是常用的，不是全部；</p>\n","prev":{"title":"[Kubernetes In Action] Service & Ingress","link":"2024/10/13/blog/k8s-service_and_ingress"},"next":{"title":"Machine-Learing：集成学习-stacking","link":"2020/10/13/blog/ensemble_learning_stacking"},"plink":"https://qfzack.github.io/2020/11/04/blog/Java_learning/","toc":[{"id":"1.-对java中泛型的理解","title":"1. 对java中泛型的理解","index":"1"},{"id":"2.-collections接口与map接口","title":"2. Collections接口与Map接口","index":"2"},{"id":"3.-lambda表达式","title":"3. Lambda表达式","index":"3"},{"id":"4.-hashmap与hashcode：","title":"4. HashMap与HashCode：","index":"4"},{"id":"5.-笔记碎片","title":"5. 笔记碎片","index":"5","children":[{"id":"001-列表list的常用方法：","title":"001 列表List的常用方法：","index":"5.1"},{"id":"002-字符串string的基本方法与字符类型char：","title":"002 字符串String的基本方法与字符类型Char：","index":"5.2"},{"id":"003-list排序与初始化：","title":"003 list排序与初始化：","index":"5.3"},{"id":"004-关于二维数组与二维list：","title":"004 关于二维数组与二维list：","index":"5.4"},{"id":"005-字符串与字符(数组)的转换","title":"005 字符串与字符(数组)的转换","index":"5.5"},{"id":"006-自定义排序方法对list进行排序：","title":"006 自定义排序方法对list进行排序：","index":"5.6"},{"id":"007-关于java中list与int[]互转的坑：","title":"007 关于Java中list与int[]互转的坑：","index":"5.7"},{"id":"008-java中的栈与队列：","title":"008 Java中的栈与队列：","index":"5.8","children":[{"id":"栈的实现与方法：","title":"栈的实现与方法：","index":"5.8.1"},{"id":"队列的实现与方法：","title":"队列的实现与方法：","index":"5.8.2"}]}]}],"reading_time":"4529 words in 30 min"}