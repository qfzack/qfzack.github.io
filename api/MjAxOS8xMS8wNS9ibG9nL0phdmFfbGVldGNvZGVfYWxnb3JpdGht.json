{"title":"Java算法笔记","date":"2019-11-06T05:00:00.000Z","date_formatted":{"ll":"Nov 6, 2019","L":"11/06/2019","MM-DD":"11-06"},"author":"Qingfeng Zhang","link":"2019/11/05/blog/Java_leetcode_algorithm","categories":["Algorithm"],"updated":"2025-04-22T16:16:32.654Z","content":"<h1 id=\"1.求最大公因数-辗转相除法\">1.求最大公因数-辗转相除法<a title=\"#1.求最大公因数-辗转相除法\" href=\"#1.求最大公因数-辗转相除法\"></a></h1>\n<p>两个数a,b的最大公因数等于max(a,b)-min(a,b),min(a,b)的最大公因数，依次执行直到其中一个数为0，另一个数就是a,b的最大公因数；（实际计算中为避免多次相减可以取余数）<br>\n将两个数a,b的最大公因数记为GCD(a,b)，假设a,b的最大公因数为g，则有</p>\n<p>a=m\\times g, b=n\\times g</p>\n<p>其中GCD(m,n)=1，假设a&gt;b，有：</p>\n<p>a-b=(m-n)\\times g</p>\n<p>GCD(m-n,n)=1,a-b,b的最大公因数依然是g。</p>\n<blockquote>\n<p><strong>NO.914 卡牌分组</strong><br>\n将卡牌分为任意组，每组的元素数量（不小于2）和值相同，是否存在这样的分组，需要计算所有数出现次数的最大公因数：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">hasGroupsSizeX</span><span class=\"params\">(<span class=\"type\">int</span>[] deck)</span> &#123;  </span><br><span class=\"line\">        Map&lt;Integer,Integer&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> n: deck)&#123;  </span><br><span class=\"line\">            map.put(n,map.containsKey(n)?map.get(n)+<span class=\"number\">1</span>:<span class=\"number\">1</span>);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">factor</span> <span class=\"operator\">=</span> map.get(deck[<span class=\"number\">0</span>]);  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(Integer n: map.keySet())&#123;  </span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> map.get(n);  </span><br><span class=\"line\">            factor = comput(num,factor);  </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(factor==<span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">comput</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b)</span>&#123;  <span class=\"comment\">//计算最大公因数  </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> b==<span class=\"number\">0</span>?a:comput(b,a%b);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<h1 id=\"2.计算质数-厄拉多塞筛法\">2.计算质数-厄拉多塞筛法<a title=\"#2.计算质数-厄拉多塞筛法\" href=\"#2.计算质数-厄拉多塞筛法\"></a></h1>\n<p>要求找出2~N范围内的所有质数，可以先找到第一个质数2，然后划掉2的倍数，然后找到下一个质数3，然后划掉3的倍数，再找到下一个质数5……这很像一个筛子，将不满足的数筛掉，留下满足要求的数，这个方法叫做<strong>厄拉多塞筛法</strong><br>\n；</p>\n<p><img src=\"images/Java_leetcode_algorithm/1.gif\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<blockquote>\n<p><strong>NO.204 计数质数</strong><br>\n统计所有小于非负整数n的质数的数量：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">countPrimes</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;  </span><br><span class=\"line\">        <span class=\"type\">boolean</span>[] A = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[n];  </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;Math.sqrt(n);i++)&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!A[i])&#123;  <span class=\"comment\">//下一个没有被划掉的就是质数  </span></span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>;  <span class=\"comment\">//从质数的2倍开始，也可以从i*i开始  </span></span><br><span class=\"line\">                <span class=\"keyword\">while</span>(i*k&lt;n)&#123;  </span><br><span class=\"line\">                    A[i*k] = <span class=\"literal\">true</span>;  <span class=\"comment\">//划掉质数的倍数  </span></span><br><span class=\"line\">                    k++;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;n;i++)&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!A[i]) count++;  <span class=\"comment\">//统计剩下的质数数量  </span></span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<h1 id=\"3.约瑟夫环问题\">3.约瑟夫环问题<a title=\"#3.约瑟夫环问题\" href=\"#3.约瑟夫环问题\"></a></h1>\n<p>约瑟夫问题：N个人围成一圈，从第一个人开始报数，报到M的将出局，下一个人接着从1开始报数，如此反复直到最后一个人即为胜利者；<br>\n这个问题可以用环形链表模拟，但是时间复杂度较高，将N个人编号为1,2,3,…N，假设N=11，M=3，则：</p>\n<ul>\n<li>\n<p>第一次，1开始报数，3出局；</p>\n</li>\n<li>\n<p>第二次，4开始报数，6出局；</p>\n</li>\n<li>\n<p>第三次，7开始报数，9出局；<br>\n……</p>\n</li>\n<li>\n<p>最后的胜利者为7；</p>\n</li>\n</ul>\n<p><img src=\"images/Java_leetcode_algorithm/2.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>这个过程的递推公式为：</p>\n<p>f(N,M) = (f(N-1,M)+M)%N</p>\n<p>可以理解为每次删掉第i个人后，将第i+1个人放在第一个位置，然后开始报数，这个讲解的很好<a href=\"https://blog.csdn.net/u011500062/article/details/72855826\" target=\"_blank\">约瑟夫问题</a>;</p>\n<blockquote>\n<p><strong>NO.面试题62 圆圈中最后剩下的数字</strong></p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">lastRemaining</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> m)</span> &#123;  </span><br><span class=\"line\">        <span class=\"comment\">//f(n,m) = (f(n-1,m)+n)%n  </span></span><br><span class=\"line\">        <span class=\"comment\">//其中f(n,m)表示有n个人间隔为m时最后剩下的数的坐标  </span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=n;i++)&#123;  </span><br><span class=\"line\">            p = (p+m)%i;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> p;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<h1 id=\"4.卡特兰数catalan\">4.卡特兰数Catalan<a title=\"#4.卡特兰数catalan\" href=\"#4.卡特兰数catalan\"></a></h1>\n<p>卡特兰数是组合数学中一个经常在各种计数问题中出现的数列，以一个问题为例：使用n个矩形拼成n阶梯形，问拼接的方法有多少种，如下图：</p>\n<p><img src=\"images/Java_leetcode_algorithm/catalan.jpg\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>n阶梯形包含n个“尖”，每一个“尖”都恰好属于一个矩形，以n=6为例，包含尖角的矩形有以下6种：</p>\n<p><img src=\"images/Java_leetcode_algorithm/catalan2.jpg\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>如果用 C_n 表示将n阶梯形分解为n个矩形的方法数，则由于每个尖角都可以将梯形分为左右两部分，如下：</p>\n<p><img src=\"images/Java_leetcode_algorithm/catalan4.jpg\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>因此有：</p>\n<p>C_6 = C_0C_5 + C_1C_4 + C_2C_3 + C_3C_2 + C_4C_1 + C_5C_0</p>\n<p>对分解的情况进行推广可以得到 C_n 一般项公式为：</p>\n<p>C_n = C_0C_{n-1}+C_1C_{n-2}+C_2C_{n-3}+…+C_{n-2}C_1+C_{n-1}C_0</p>\n<p>其中n与 C_n 可以由下式表达：</p>\n<p>C_n = \\frac{1}{n+1}\\dbinom{2n}{n} = \\frac{1}{n+1}C_{n}^{2n} =<br>\n\\frac{(2n)!}{(n+1)!n!}</p>\n<blockquote>\n<p><strong>常见问题</strong></p>\n</blockquote>\n<p><strong>1.括号匹配：</strong><br>\n给定n个’(‘和n个’)’，要求左括号和右括号是匹配的，求可能的结果；</p>\n<p><img src=\"images/Java_leetcode_algorithm/catalan6.jpg\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p><strong>2.Dyck words：</strong><br>\n给定n个’X’和n个’Y’组成字符串，要求从第一个字符开始的子串中’X’的个数不少于’Y’的个数，求可能的结果；</p>\n<p><strong>3.标准Yang表：</strong><br>\n给定一个2*n的方格表，填入数字1~2n，要求每行自左而右、每列自上而下都是严格递增的，求有多少种填法；<br>\n如果令第一行的值表示’(‘的位置，第二行的值表示’)’的位置，那么这个问题和括号匹配一样；</p>\n<p><img src=\"images/Java_leetcode_algorithm/catalan5.jpg\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p><strong>4.不相交的弦：</strong><br>\n在一个源上分布着2n个点，连接两点得到一天弦，共有n条弦，要求弦之间不相交，求连接的方式总数；<br>\n如果从圆上某一点开始沿着圆周，遇到某条弦的第一个点写下一个’(‘，遇到某条弦的第二个点写下一个’)’，这个问题也可以转换为括号匹配问题；</p>\n<p><img src=\"images/Java_leetcode_algorithm/catalan7.jpg\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p><strong>5.出栈序列：</strong><br>\n假设入栈顺序为1,2,…,n，求所有可能的出栈序列，这其实也和括号匹配一样；</p>\n<p><strong>6.笔画“群峰”：</strong><br>\n使用n个斜向上的线段和n个相同长度的斜向下的线段，画出“群峰”；如果用’(‘代替斜向上的线段，’)’代替斜向下的线段，则可以转换为括号匹配的问题；</p>\n<p><img src=\"images/Java_leetcode_algorithm/catalan8.jpg\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p><strong>7.满位置二叉树的计数：</strong><br>\n有n+1个叶子节点的满位置二叉树(每个节点有0或2个子节点)的种数；<br>\n例如当n=3，有以下5种满位置二叉树：</p>\n<p><img src=\"images/Java_leetcode_algorithm/catalan10.jpg\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>考虑树的前序遍历：第一次遇到一个非叶子节点，写下一个’(‘，第二次遇到一个非叶子节点，写下一个’)’，从而将问题转换为括号匹配；</p>\n<p><img src=\"images/Java_leetcode_algorithm/catalan9.jpg\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<blockquote>\n<p><strong>NO.22 括号生成</strong></p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;  </span><br><span class=\"line\">    List&lt;String&gt; l = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title function_\">generateParenthesis</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;  </span><br><span class=\"line\">        dfs(<span class=\"string\">&quot;&quot;</span>,n,<span class=\"number\">0</span>,<span class=\"number\">0</span>);  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> l;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">dfs</span><span class=\"params\">(String s,<span class=\"type\">int</span> n,<span class=\"type\">int</span> left,<span class=\"type\">int</span> right)</span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.length()==<span class=\"number\">2</span>*n)&#123;  </span><br><span class=\"line\">            l.add(s);  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> ;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(left&lt;n)&#123;  </span><br><span class=\"line\">            dfs(s+<span class=\"string\">&#x27;(&#x27;</span>,n,left+<span class=\"number\">1</span>,right);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(right&lt;left)&#123;  </span><br><span class=\"line\">            dfs(s+<span class=\"string\">&#x27;)&#x27;</span>,n,left,right+<span class=\"number\">1</span>);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n","prev":{"title":"Leetcode算法题集(Java)","link":"2019/12/12/blog/Java_leetcode_note"},"next":{"title":"Python-回溯算法","link":"2019/10/10/blog/backtracking"},"plink":"https://qfzack.github.io/2019/11/05/blog/Java_leetcode_algorithm/","toc":[{"id":"1.求最大公因数-辗转相除法","title":"1.求最大公因数-辗转相除法","index":"1"},{"id":"2.计算质数-厄拉多塞筛法","title":"2.计算质数-厄拉多塞筛法","index":"2"},{"id":"3.约瑟夫环问题","title":"3.约瑟夫环问题","index":"3"},{"id":"4.卡特兰数catalan","title":"4.卡特兰数Catalan","index":"4"}],"reading_time":"1683 words in 11 min"}