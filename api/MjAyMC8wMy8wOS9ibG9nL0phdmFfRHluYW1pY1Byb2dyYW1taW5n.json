{"title":"Java-动态规划算法","date":"2020-03-10T05:00:00.000Z","date_formatted":{"ll":"Mar 10, 2020","L":"03/10/2020","MM-DD":"03-10"},"author":"Qingfeng Zhang","link":"2020/03/09/blog/Java_DynamicProgramming","categories":["Algorithm"],"updated":"2025-04-30T05:18:56.920Z","content":"<p>动态规划的一般形式是求<strong>最值</strong> ，这个过程中会对问题的可能解答进行穷举，因为这类问题会存在<strong>重叠子问题</strong> ，暴力穷举效率会非常低，所以需要<strong>DP<br>\ntable</strong> 来优化穷举的过程，避免不必要的计算，此外，动态规划问题会具备<strong>最优子结构</strong> ，因此才能由子问题的最值得到原问题的最值；<br>\n动态规划的三个要素是：重叠子问题，最优子结构，状态转移方程；<br>\n把所求的结果一步步分解称作<code>自顶向下</code>，而从最简单、规模最小的问题逐步求得最终解称作<code>自底向上</code>；</p>\n<h1 id=\"2020-3-29-关于动态规划的一些总结\">2020-3-29 关于动态规划的一些总结<a title=\"#2020-3-29-关于动态规划的一些总结\" href=\"#2020-3-29-关于动态规划的一些总结\"></a></h1>\n<p>最近一直在做动态规划的一些中等题，感觉智商急剧下降，经常自闭，今天做题突然有了一下感悟，就在这总结一下；<br>\n有些动态规划题会给出一个备选的数组，然后给定一个目标值，要求找出用数组中的值达到目标值的所有可能种数;<br>\n我把这类问题分为两种：给定数组中的元素不能重复使用和可以重复使用，而这两种情况对应着两种不同的解题策略：</p>\n<p>1.<strong>遍历给定数组的每个元素，每次更新dp数组的值，从而得到计算结果</strong><br>\n2.<strong>按索引顺序遍历dp数组，每次更新dp数组当前位置的值，从而得到计算结果</strong></p>\n<p>先说下0-1背包问题，0-1背包问题给定n个重量为<code>w_1,w_2,...,w_n</code>，价值为<code>v_1,v_2,...,v_n</code>的物品和一个容量为<code>C</code>的背包，求能装下的物品的最大价值，这个问题中就会要求每个物品只能使用一次，这里可以定义dp[i][j]为加入第i个物品且容量为j时的最大价值，也可以将dp定义为一维数组，表示容量为i时的最大价值，然后逐个放入物品然后更新dp，下面的例子中C=11，有5件物品：<br>\n<img src=\"images/Java_DynamicProgramming/1.jpg\" alt=\"\" loading=\"lazy\"><br>\n0-1背包问题中有两个状态，也就是物品i和容量c，因此需要一个两层循环遍历，每次有两种选择：将第i个物品放入背包和不放入背包。</p>\n<ul>\n<li>如<code>NO.322 零钱兑换</code>给定一个数组表示不同面额的硬币和一个总金额，求用总金额兑换的最少硬币数量，<strong>数组值可以重复使用</strong> ；</li>\n<li>如<code>NO.377 组合总和IV</code>给定一个无重复的数组和一个目标数，找出和为目标数的组合的个数，<strong>数组值可以重复使用</strong> ；</li>\n<li>如<code>NO.416 分割等和子集</code>给定一个数组，问能否将这个数组分为两个和相等的部分，其实就是判断是否有等于sum/2的组合，<strong>数组值不能重复使用</strong> ；</li>\n<li>如<code>NO.474 一和零</code>中给定一个字符串数组，其中每个字符都是0或1，然后给定一个目标：0的数量m和1的数量n，要求出用这m个0和n个1可以组成数组中的字符串的数量，<strong>数组值不能重复使用</strong> ；</li>\n<li>如<code>NO.494 目标和</code>中给定一个非负整数数组和一个目标数，对于数组中的数可以添加<code>+</code>或<code>-</code>号，求添加符号后运算的结果等于目标数的组合数量，<strong>数组值不能重复使用</strong> ；</li>\n</ul>\n<p>但是这类问题也不能一概而论，像<code>NO.139 单词拆分</code>也是判断能否用字符串数组中的字符串（可以重复使用）组成给定字符串，但是用动态规划加String.contains()更方便。</p>\n<h1 id=\"1.股票问题\">1.股票问题<a title=\"#1.股票问题\" href=\"#1.股票问题\"></a></h1>\n<p>股票问题可以用一个三维dp数组来说清楚：dp[i][k][0 or<br>\n1]，表示当前为第i天且已经进行了k次交易，手上是否持有股票(1表示持有，0表示不持有)时的最大利润；<br>\n最终的最大利润即在最后一天不持有股票且用完交易次数时的利润，对于比较简单的<code>NO.121</code>、<code>NO.122</code>、<code>NO.309</code>，可以将这个三维的dp数组减少到二维，因为交易次数是1或是无穷，也可以用两个一维数组甚至几个变量来实现动态规划；<br>\n但是对于<code>NO.123</code>这种限定了交易次数的情况，就需要使用dp数组中的这个维度，因此dp数组为三维或是两个二维数组；</p>\n<h2 id=\"no.121-买卖股票的最佳时机\">NO.121 买卖股票的最佳时机<a title=\"#no.121-买卖股票的最佳时机\" href=\"#no.121-买卖股票的最佳时机\"></a></h2>\n<p>给定一个数组，第i个值表示第i天的股票价格，要求<strong>只能完成一笔交易</strong>(买入和卖出)，求最大的收益；<br>\n这是最基础的动态规划问题，只需要用一个变量记录第i天之前的股票最低价格min，就可以得到第i天卖出的收益<code>prices[i]-min</code>，记录收益的最大值就是结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> &#123;  </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">min</span> <span class=\"operator\">=</span> Integer.MAX_VALUE;  </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">profit</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;prices.length;i++)&#123;  </span><br><span class=\"line\">            min = Math.min(min,prices[i]);  </span><br><span class=\"line\">            profit = Math.max(profit,prices[i]-min);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> profit;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<h2 id=\"no.122-买卖股票的最佳时机ii\">NO.122 买卖股票的最佳时机II<a title=\"#no.122-买卖股票的最佳时机ii\" href=\"#no.122-买卖股票的最佳时机ii\"></a></h2>\n<p>又是一道经典的股票问题，与上一题不同的地方在于没有限制股票的买入卖出次数，同样要求最大的利润；<br>\n根据股票问题的动态规划解题思路，每一天都有两种状态：持有股票和不持有股票，因此可以建立两个dp数组，分别表示两种状态每一天的当前利润（也就是每个值表示当前身上的总金额），那么dp数组如何更新？</p>\n<p>对于<strong>持有股票的dp1</strong><br>\n，如果在第i天持有股票，可能是第i-1天就持有股票没卖出，也可能是第i-1天不持有股票，并且在第i天买入当天的股票；同理，对于不持有股票的dp2，如果在第i天不持有股票，可能是第i-1天就不持有股票，也可能是第i-1天持有股票，并且在第i天当天卖出，因此两个dp数组的计算公式为：</p>\n<p>dp1[i]=max(dp1[i-1],dp2[i-1]-prices[i])</p>\n<p>dp2[i]=max(dp2[i-1],dp1[i-1]+prices[i])</p>\n<p>(Python语法是真的简洁…)在最后一天不持有股票时的总金额就是最大利润；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(prices.length&lt;=<span class=\"number\">1</span>)&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp1 = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[prices.length];  </span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp2 = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[prices.length];  </span><br><span class=\"line\">        dp1[<span class=\"number\">0</span>] = -prices[<span class=\"number\">0</span>];  </span><br><span class=\"line\">        dp2[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;prices.length;i++)&#123;  </span><br><span class=\"line\">            dp1[i] = dp1[i-<span class=\"number\">1</span>]&gt;dp2[i-<span class=\"number\">1</span>]-prices[i]?dp1[i-<span class=\"number\">1</span>]:dp2[i-<span class=\"number\">1</span>]-prices[i];  </span><br><span class=\"line\">            dp2[i] = dp2[i-<span class=\"number\">1</span>]&gt;dp1[i-<span class=\"number\">1</span>]+prices[i]?dp2[i-<span class=\"number\">1</span>]:dp1[i-<span class=\"number\">1</span>]+prices[i];  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp2[dp2.length-<span class=\"number\">1</span>];  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>但是提交之后时间并不是很好，看来还有更好的解法，果不其然，贪心法才是这题的最优解法；<br>\n贪心思想就是如果价格上涨我就前一天买入，然后卖出（题目也说可以买卖同一支股票，因此可以同一天买入卖出），然后累加收益就行；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(prices.length&lt;=<span class=\"number\">1</span>)&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">profit</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;prices.length;i++)&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(prices[i-<span class=\"number\">1</span>]&lt;prices[i])&#123;  </span><br><span class=\"line\">                profit += prices[i]-prices[i-<span class=\"number\">1</span>];  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> profit;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<h2 id=\"no.123-买卖股票的最佳时机iii\">NO.123 买卖股票的最佳时机III<a title=\"#no.123-买卖股票的最佳时机iii\" href=\"#no.123-买卖股票的最佳时机iii\"></a></h2>\n<p>与上一题的区别在于限定交易的次数为2次，上面两道题的交易次数为1和不限制，比较好做，因此这道题需要在dp数组中加上一个维度表示交易的次数；<br>\n令dp1[i][j]表示持有股票且交易j次时的利润，dp2[i][j]表示不持有股票且交易j次时的利润，因此，在遍历prices数组的时候，对于每天的股票价格，需要再计算交易次数为1，2时的最大利润，也就是多了一层循环；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(prices.length==<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp1 = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[prices.length][<span class=\"number\">3</span>];  <span class=\"comment\">//dp1[i][j]表示持有股票且交易j次时的利润  </span></span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp2 = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[prices.length][<span class=\"number\">3</span>];  <span class=\"comment\">//dp2[i][j]表示不持有股票且交易j次时的利润  </span></span><br><span class=\"line\">        dp1[<span class=\"number\">0</span>][<span class=\"number\">1</span>] = dp1[<span class=\"number\">0</span>][<span class=\"number\">2</span>] = -prices[<span class=\"number\">0</span>];  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;prices.length;i++)&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k=<span class=\"number\">1</span>;k&lt;=<span class=\"number\">2</span>;k++)&#123;  </span><br><span class=\"line\">                dp1[i][k] = Math.max(dp1[i-<span class=\"number\">1</span>][k],dp2[i-<span class=\"number\">1</span>][k-<span class=\"number\">1</span>]-prices[i]);  <span class=\"comment\">//买入算一次交易  </span></span><br><span class=\"line\">                dp2[i][k] = Math.max(dp2[i-<span class=\"number\">1</span>][k],dp1[i-<span class=\"number\">1</span>][k]+prices[i]);    </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp2[prices.length-<span class=\"number\">1</span>][<span class=\"number\">2</span>];  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>可以省略为四个变量，想想！</p>\n</blockquote>\n<h2 id=\"no.188-买卖股票的最佳时机iv\">NO.188 买卖股票的最佳时机IV<a title=\"#no.188-买卖股票的最佳时机iv\" href=\"#no.188-买卖股票的最佳时机iv\"></a></h2>\n<p>这题的交易次数有限制，但是限制次数是一个变量，因此分两种情况：如果次数达到了prices数组的一半，则相当于次数没限制，此时和NO.122一样；否则就按照NO.123的思路进行求解；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span> k, <span class=\"type\">int</span>[] prices)</span> &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(prices.length==<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(k&gt;=prices.length/<span class=\"number\">2</span>)&#123;  <span class=\"comment\">//当建议次数达到prices长度的一半，相当于没限制，与之前的股票交易问题一样  </span></span><br><span class=\"line\">            <span class=\"type\">int</span>[] dp1 = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[prices.length];  </span><br><span class=\"line\">            <span class=\"type\">int</span>[] dp2 = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[prices.length];  </span><br><span class=\"line\">            dp1[<span class=\"number\">0</span>] = -prices[<span class=\"number\">0</span>];  </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;prices.length;i++)&#123;  </span><br><span class=\"line\">                dp1[i] = Math.max(dp1[i-<span class=\"number\">1</span>],dp2[i-<span class=\"number\">1</span>]-prices[i]);  </span><br><span class=\"line\">                dp2[i] = Math.max(dp2[i-<span class=\"number\">1</span>],dp1[i-<span class=\"number\">1</span>]+prices[i]);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> dp2[prices.length-<span class=\"number\">1</span>];  </span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;    </span><br><span class=\"line\">            <span class=\"type\">int</span>[][] dp1 = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[prices.length][k+<span class=\"number\">1</span>];  <span class=\"comment\">//持有的dp数组  </span></span><br><span class=\"line\">            <span class=\"type\">int</span>[][] dp2 = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[prices.length][k+<span class=\"number\">1</span>];  <span class=\"comment\">//不持有的dp数组  </span></span><br><span class=\"line\">            System.out.println(k);  </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> n=<span class=\"number\">1</span>;n&lt;=k;n++)&#123;  </span><br><span class=\"line\">                dp1[<span class=\"number\">0</span>][n] = -prices[<span class=\"number\">0</span>];  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;prices.length;i++)&#123;  </span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> n=<span class=\"number\">1</span>;n&lt;=k;n++)&#123;  </span><br><span class=\"line\">                    dp1[i][n] = Math.max(dp1[i-<span class=\"number\">1</span>][n],dp2[i-<span class=\"number\">1</span>][n-<span class=\"number\">1</span>]-prices[i]);  <span class=\"comment\">//买入算一次交易  </span></span><br><span class=\"line\">                    dp2[i][n] = Math.max(dp2[i-<span class=\"number\">1</span>][n],dp1[i-<span class=\"number\">1</span>][n]+prices[i]);  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> dp2[prices.length-<span class=\"number\">1</span>][k];  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<h2 id=\"no.309-最佳买卖股票时机含冷冻期\">NO.309 最佳买卖股票时机含冷冻期<a title=\"#no.309-最佳买卖股票时机含冷冻期\" href=\"#no.309-最佳买卖股票时机含冷冻期\"></a></h2>\n<p>问题定义与一般的股票问题一样，不同之处在于这里的买卖股票包含冷冻期，即当天卖出之后第二天不能再买入（冷冻期一天）；<br>\n依然是定义dp1[i]为第i天持有股票的最大收益，dp2[i]为第i天不持有股票的最大收益，对于冷冻期这个限制，只需要在更新dp1[i]的时候使用dp1[i-1],dp2[i-2]和prices[i]即可，为什么是dp2[i-2]下面给出解释：<br>\n如果没有冷冻期的话就是用dp2[i-1]没问题；对于昨天不持有股票可能是昨天卖了(dp1[i-1]+prices[1])或是没卖(dp2[i-1])，但是如果是卖了而得到最大收益，会因为有冷冻期而不考虑，即：<br>\ndp2[i] = max(dp2[i-1],dp1[i-1]+prices[i])<br>\n因为dp1[i-1]+prices[i]不被考虑，所以对于dp1[i+1]来说，dp2[i]==dp2[i]，所以要取前前一天的dp2，因此得到dp1和dp2的更新公式：<br>\ndp1[i] = max(dp1[i-1],dp2[i-1]+prices[i])<br>\ndp2[i] = max(dp2[i-1],dp1[i-2]+prices[i])</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> &#123;  </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> prices.length;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(len==<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp1 = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[len+<span class=\"number\">1</span>];  </span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp2 = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[len+<span class=\"number\">1</span>];  </span><br><span class=\"line\">        dp1[<span class=\"number\">1</span>] = -prices[<span class=\"number\">0</span>];  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=len;i++)&#123;  </span><br><span class=\"line\">            dp1[i] = Math.max(dp1[i-<span class=\"number\">1</span>],dp2[i-<span class=\"number\">2</span>]-prices[i-<span class=\"number\">1</span>]);  </span><br><span class=\"line\">            dp2[i] = Math.max(dp2[i-<span class=\"number\">1</span>],dp1[i-<span class=\"number\">1</span>]+prices[i-<span class=\"number\">1</span>]);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp2[len];  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>可以使用三个变量代替两个数组，优化空间：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(prices.length==<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">dp1</span> <span class=\"operator\">=</span> -prices[<span class=\"number\">0</span>], dp2 = <span class=\"number\">0</span>, pre = <span class=\"number\">0</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;prices.length;i++)&#123;  </span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">tmp</span> <span class=\"operator\">=</span> dp2;  </span><br><span class=\"line\">            dp2 = Math.max(dp2,dp1+prices[i]);  </span><br><span class=\"line\">            dp1 = Math.max(dp1,pre-prices[i]);  </span><br><span class=\"line\">            pre = tmp;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp2;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<h1 id=\"2.打家劫舍\">2.打家劫舍<a title=\"#2.打家劫舍\" href=\"#2.打家劫舍\"></a></h1>\n<h2 id=\"no.198-打家劫舍\">NO.198 打家劫舍<a title=\"#no.198-打家劫舍\" href=\"#no.198-打家劫舍\"></a></h2>\n<p>给定一个数组，数组的每个元素表示房屋内可以偷窃的金额，但是不能连续盗窃两家，否则会触发警报，求最大可偷窃的金额；<br>\n当小偷走到某一家的时候有两种选择：1.偷窃这并且前一家没有偷窃；2.不偷窃这家，说明偷窃了前一家；因此在当前位置可以获得的最大金额是这两种情况中的，可以定义一个dp数组，其中dp[i]表示在<strong>前i家可以偷窃的最大金额</strong><br>\n，用状态转移方程表示就是：<br>\n<code>dp[i] = max(dp[i-1], dp[i-2]+nums[i])</code><br>\n可以将数组改为常数个变量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">rob</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;  </span><br><span class=\"line\">        <span class=\"comment\">// if(nums.length==0) return 0;  </span></span><br><span class=\"line\">        <span class=\"comment\">// int[] dp = new int[nums.length+1];  </span></span><br><span class=\"line\">        <span class=\"comment\">// dp[1] = nums[0];  </span></span><br><span class=\"line\">        <span class=\"comment\">// for(int i=2;i&lt;=nums.length;i++)&#123;  </span></span><br><span class=\"line\">        <span class=\"comment\">//     dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i-1]);  </span></span><br><span class=\"line\">        <span class=\"comment\">// &#125;  </span></span><br><span class=\"line\">        <span class=\"comment\">// return dp[nums.length];  </span></span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.length==<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">        <span class=\"type\">int</span> tmp1=<span class=\"number\">0</span>, tmp2=nums[<span class=\"number\">0</span>];  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;nums.length;i++)&#123;  </span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">tmp</span> <span class=\"operator\">=</span> Math.max(tmp2,tmp1+nums[i]);  </span><br><span class=\"line\">            tmp1 = tmp2;  </span><br><span class=\"line\">            tmp2 = tmp;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> tmp2;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<h2 id=\"no.213-打家劫舍ii\">NO.213 打家劫舍II<a title=\"#no.213-打家劫舍ii\" href=\"#no.213-打家劫舍ii\"></a></h2>\n<p>这道题与上面的打家劫舍唯一的不同是房屋是首尾相连的，也就是不同同时偷窃第一家和最后一家；<br>\n在计算后面的最大值时，怎么知道这个最大金额有没有包括第一家的？一开始想在为每一个金额设置一个标签，表示这里的金额中是否包含第一家，然后在最后一家和倒数第二家中取最大值，但是问题是这两家的金额可能都包含第一家的啊。。。<br>\n按照题目的要求，结果有两种可能：1.没有偷窃了第一家，最后一家有没有偷窃不重要；2.没有偷窃了最后一家，有没有偷窃第一家不重要（这里的不重要是按照动态规划计算最大值，能让结果最大就行）；基于此分析，可以设置两个dp数组分别表示两种情况的结果，而每种情况的计算就和上一题一样了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">rob</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.length==<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.length==<span class=\"number\">1</span>) <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];  </span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp1 = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums.length+<span class=\"number\">1</span>];  </span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp2 = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums.length+<span class=\"number\">1</span>];  </span><br><span class=\"line\">        dp1[<span class=\"number\">1</span>] = nums[<span class=\"number\">0</span>];  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=nums.length;i++)&#123;  </span><br><span class=\"line\">            dp1[i] = Math.max(dp1[i-<span class=\"number\">1</span>],dp1[i-<span class=\"number\">2</span>]+nums[i-<span class=\"number\">1</span>]);  </span><br><span class=\"line\">            dp2[i] = Math.max(dp2[i-<span class=\"number\">1</span>],dp2[i-<span class=\"number\">2</span>]+nums[i-<span class=\"number\">1</span>]);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.max(dp1[nums.length-<span class=\"number\">1</span>],dp2[nums.length]);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<h2 id=\"no.337-打家劫舍iii\">NO.337 打家劫舍III<a title=\"#no.337-打家劫舍iii\" href=\"#no.337-打家劫舍iii\"></a></h2>\n<p>这次偷窃的是按照树形排列的房屋，并且要求不能同时偷窃相连的两个房屋，求可以盗取的最大金额；<br>\n本来一看到打家劫舍就想到了动态规划，但是这居然是一个树的问题，又要用到DFS；但是还是用到了基本动态规划的思想，除了房屋的位置和树结构相似，其他和最基本的打家劫舍问题一样，对于当前的节点有两种选择：1.盗取当前的节点，然后放弃左右孩子节点；2.放弃当前节点，从左右孩子节点中盗取最大值，按照此思路实现的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">rob</span><span class=\"params\">(TreeNode root)</span> &#123;  </span><br><span class=\"line\">        <span class=\"comment\">// 最高金额是下面的最大值：  </span></span><br><span class=\"line\">        <span class=\"comment\">// 1.抢劫当前节点和抢劫左右节点的子树的值；  </span></span><br><span class=\"line\">        <span class=\"comment\">// 2.抢劫当前节点的左右子树的值；  </span></span><br><span class=\"line\">        <span class=\"comment\">// 依次递归求解  </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(root==<span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">val</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(root.left!=<span class=\"literal\">null</span>) val += rob(root.left.left)+rob(root.left.right);  </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(root.right!=<span class=\"literal\">null</span>) val += rob(root.right.left)+rob(root.right.right);  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> Math.max(root.val+val,rob(root.left)+rob(root.right));  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>上面的写法很费时，按照上面的思想，可以用长度为2的dp数组完成,dp[0]表示不抢劫当前节点所得到的最多的钱，dp[1]表示抢劫当前节点得到的最多的钱，每一个节点都有一个dp数组，最后得到根节点的dp数组就是结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">rob</span><span class=\"params\">(TreeNode root)</span> &#123;  </span><br><span class=\"line\">        <span class=\"type\">int</span>[] result = dp(root);  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.max(result[<span class=\"number\">0</span>],result[<span class=\"number\">1</span>]);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] dp(TreeNode root)&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">2</span>];  </span><br><span class=\"line\">        <span class=\"type\">int</span>[] l = dp(root.left);  </span><br><span class=\"line\">        <span class=\"type\">int</span>[] r = dp(root.right);  </span><br><span class=\"line\">        <span class=\"type\">int</span>[] tmp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">2</span>];  <span class=\"comment\">// 当前节点的dp数组  </span></span><br><span class=\"line\">        tmp[<span class=\"number\">0</span>] = Math.max(l[<span class=\"number\">0</span>],l[<span class=\"number\">1</span>])+Math.max(r[<span class=\"number\">0</span>],r[<span class=\"number\">1</span>]);  <span class=\"comment\">//不抢劫root的最大获益  </span></span><br><span class=\"line\">        tmp[<span class=\"number\">1</span>] = root.val+l[<span class=\"number\">0</span>]+r[<span class=\"number\">0</span>];  <span class=\"comment\">//抢劫root的最大获益  </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> tmp;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<h1 id=\"3.字符串公共子序列问题\">3.字符串公共子序列问题<a title=\"#3.字符串公共子序列问题\" href=\"#3.字符串公共子序列问题\"></a></h1>\n<p>这类问题是以求两个字符串的公共子序列为基础的，不要求公共子序列连续，但是要保证顺序不变，如:<code>abcdef</code>和<code>aceg</code>的公共子序列<code>ace</code>；</p>\n<h2 id=\"no.583-两个字符串的删除操作\">NO.583 两个字符串的删除操作<a title=\"#no.583-两个字符串的删除操作\" href=\"#no.583-两个字符串的删除操作\"></a></h2>\n<p>给定两个单词word1和word2，每次可以任意删除两个单词中的一个字母，要使得删除后两个单词相同，求最少的删除次数；<br>\n这题其实就是包装了一下的最长公共子序列，最要求出两个单词最长的公共子序列，删除次数也就确定了；<br>\n定义dp[i][j]为word1的[0,i]与word2的[0,j]的最长公共子序列，dp的更新策略为:</p>\n<p>dp[i][j]= \\begin{cases} dp[i-1][j-1]+1&amp; \\text{if word1[i]=word2[j]}\\<br>\nmax(dp[i-1][j],dp[i][j-1])&amp; \\text{otherwise} \\end{cases}</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">minDistance</span><span class=\"params\">(String word1, String word2)</span> &#123;  </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">len1</span> <span class=\"operator\">=</span> word1.length(), len2 = word2.length();  </span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[len1+<span class=\"number\">1</span>][len2+<span class=\"number\">1</span>];  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=len1;i++)&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=len2;j++)&#123;  </span><br><span class=\"line\">                <span class=\"keyword\">if</span>(word1.charAt(i-<span class=\"number\">1</span>)==word2.charAt(j-<span class=\"number\">1</span>))&#123;  </span><br><span class=\"line\">                    dp[i][j] = dp[i-<span class=\"number\">1</span>][j-<span class=\"number\">1</span>]+<span class=\"number\">1</span>;  </span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;  </span><br><span class=\"line\">                    dp[i][j] = Math.max(dp[i-<span class=\"number\">1</span>][j],dp[i][j-<span class=\"number\">1</span>]);  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> len1+len2-<span class=\"number\">2</span>*dp[len1][len2];  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<h2 id=\"no.712-两个字符串的最小ascii删除和\">NO.712 两个字符串的最小ASCII删除和<a title=\"#no.712-两个字符串的最小ascii删除和\" href=\"#no.712-两个字符串的最小ascii删除和\"></a></h2>\n<p>给定两个字符串s1和s2，同样进行<code>NO.583</code>中的删除操作使得两个字符串相等，求删除的字符的ASCII值的和；<br>\n这题虽然过程和上题一样，但是所求的结果不一样，这里需要知道删去字符的ASCII值的和，因此，可以定义dp[i][j]表示使得s1的[0,i]和s2的[0,j]相等的删除字符的ASCII之和，从而写出dp的更新策略为：</p>\n<p>dp[i][j]= \\begin{cases} dp[i-1][j-1]&amp; \\text{if word1[i]=word2[j]}\\<br>\nmin(dp[i-1][j]+s1[i],dp[i][j-1]+s2[j],dp[i-1][j-1]+s1[i]+s2[j])&amp;<br>\n\\text{otherwise} \\end{cases}</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">minimumDeleteSum</span><span class=\"params\">(String s1, String s2)</span> &#123;  </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">len1</span> <span class=\"operator\">=</span> s1.length(), len2 = s2.length();  </span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[len1+<span class=\"number\">1</span>][len2+<span class=\"number\">1</span>];  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=len1;i++)&#123;  </span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = dp[i-<span class=\"number\">1</span>][<span class=\"number\">0</span>]+(<span class=\"type\">int</span>)s1.charAt(i-<span class=\"number\">1</span>);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=len2;j++)&#123;  </span><br><span class=\"line\">            dp[<span class=\"number\">0</span>][j] = dp[<span class=\"number\">0</span>][j-<span class=\"number\">1</span>]+(<span class=\"type\">int</span>)s2.charAt(j-<span class=\"number\">1</span>);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=len1;i++)&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=len2;j++)&#123;  </span><br><span class=\"line\">                <span class=\"keyword\">if</span>(s1.charAt(i-<span class=\"number\">1</span>)==s2.charAt(j-<span class=\"number\">1</span>))&#123;  </span><br><span class=\"line\">                    dp[i][j] = dp[i-<span class=\"number\">1</span>][j-<span class=\"number\">1</span>];  </span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;  </span><br><span class=\"line\">                    dp[i][j] = Math.min(dp[i-<span class=\"number\">1</span>][j-<span class=\"number\">1</span>]+(<span class=\"type\">int</span>)s1.charAt(i-<span class=\"number\">1</span>)+(<span class=\"type\">int</span>)s2.charAt(j-<span class=\"number\">1</span>),Math.min(dp[i-<span class=\"number\">1</span>][j]+(<span class=\"type\">int</span>)s1.charAt(i-<span class=\"number\">1</span>),dp[i][j-<span class=\"number\">1</span>]+(<span class=\"type\">int</span>)s2.charAt(j-<span class=\"number\">1</span>)));  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[len1][len2];  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<h2 id=\"no.1035-不相交的线\">NO.1035 不相交的线<a title=\"#no.1035-不相交的线\" href=\"#no.1035-不相交的线\"></a></h2>\n<p>给定两个数组表示两条平行线，数组值表示线上点的坐标，可以将两条水平线上的点进行相连，但是每条线不能相交，求线的最大数量；<br>\n这题乍一看不好做，但是者其实只是包装的比较好而已，剥掉外壳会发现这和<code>NO.583</code>一模一样，也是求最长公共子序列；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxUncrossedLines</span><span class=\"params\">(<span class=\"type\">int</span>[] A, <span class=\"type\">int</span>[] B)</span> &#123;  </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">len1</span> <span class=\"operator\">=</span> A.length, len2 = B.length;  </span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[len1+<span class=\"number\">1</span>][len2+<span class=\"number\">1</span>];  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=len1;i++)&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=len2;j++)&#123;  </span><br><span class=\"line\">                <span class=\"keyword\">if</span>(A[i-<span class=\"number\">1</span>]==B[j-<span class=\"number\">1</span>])&#123;  </span><br><span class=\"line\">                    dp[i][j] =  dp[i-<span class=\"number\">1</span>][j-<span class=\"number\">1</span>]+<span class=\"number\">1</span>;  </span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;  </span><br><span class=\"line\">                    dp[i][j] = Math.max(dp[i-<span class=\"number\">1</span>][j],dp[i][j-<span class=\"number\">1</span>]);  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[len1][len2];  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<h2 id=\"no.72-编辑距离\">NO.72 编辑距离<a title=\"#no.72-编辑距离\" href=\"#no.72-编辑距离\"></a></h2>\n<p>题目一般是按题号升序，但是这是道困难题，所以就放这里了；<br>\n给定两个单词word1和word2，可以对任意一个单词进行三种操作：插入一个字符、删除一个字符、替换一个字符，结果还是使得两个单词相等，求最少的操作次数；<br>\n这题和<code>NO.583</code>很像，但是<code>NO.583</code>只能删除，这里还可以插入和替换，似乎不好办，但是可以参照<code>NO.712</code>的思路，重新定义dp数组，这里按照题意定义dp[i][j]为使得word1的[0,i]和word2[0,j]相等的最少操作次数，从而写出dp的更新策略为：</p>\n<p>dp[i][j]= \\begin{cases} dp[i-1][j-1]&amp; \\text{if word1[i]=word2[j]}\\<br>\nmin(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1&amp; \\text{otherwise} \\end{cases}</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">minDistance</span><span class=\"params\">(String word1, String word2)</span> &#123;  </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">len1</span> <span class=\"operator\">=</span> word1.length(), len2 = word2.length();  </span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[len1+<span class=\"number\">1</span>][len2+<span class=\"number\">1</span>];  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=len1;i++)&#123;  </span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = i;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=len2;j++)&#123;  </span><br><span class=\"line\">            dp[<span class=\"number\">0</span>][j] = j;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=len1;i++)&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=len2;j++)&#123;  </span><br><span class=\"line\">                <span class=\"keyword\">if</span>(word1.charAt(i-<span class=\"number\">1</span>)==word2.charAt(j-<span class=\"number\">1</span>))&#123;  </span><br><span class=\"line\">                    dp[i][j] = dp[i-<span class=\"number\">1</span>][j-<span class=\"number\">1</span>];  </span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;  </span><br><span class=\"line\">                    dp[i][j] = Math.min(dp[i-<span class=\"number\">1</span>][j-<span class=\"number\">1</span>],Math.min(dp[i][j-<span class=\"number\">1</span>],dp[i-<span class=\"number\">1</span>][j]))+<span class=\"number\">1</span>;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[len1][len2];  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">```      </span><br><span class=\"line\">  </span><br><span class=\"line\"># 其他的动态规划问题</span><br><span class=\"line\"></span><br><span class=\"line\">## NO<span class=\"number\">.91</span> 解码方法</span><br><span class=\"line\"></span><br><span class=\"line\">给定一个数字组成的字符串，通过`<span class=\"string\">&#x27;A&#x27;</span>-&gt;<span class=\"number\">1</span>,<span class=\"string\">&#x27;B&#x27;</span>-&gt;<span class=\"number\">2</span>,...,<span class=\"string\">&#x27;Z&#x27;</span>-&gt;<span class=\"number\">26</span>`对字符串进行解码，求解码方法的总数；  </span><br><span class=\"line\">看一个例子：[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>]有三种解码：  </span><br><span class=\"line\"><span class=\"number\">1</span> - <span class=\"number\">2</span> - <span class=\"number\">2</span>  </span><br><span class=\"line\"><span class=\"number\">12</span> - <span class=\"number\">2</span>  </span><br><span class=\"line\"><span class=\"number\">1</span> - <span class=\"number\">22</span>  </span><br><span class=\"line\">加入一个新元素<span class=\"number\">2</span>之后有<span class=\"number\">3</span>+<span class=\"number\">2</span>种解码：  </span><br><span class=\"line\"><span class=\"number\">1</span> - <span class=\"number\">2</span> - <span class=\"number\">2</span> - ‘<span class=\"number\">2</span>’  </span><br><span class=\"line\"><span class=\"number\">12</span> - <span class=\"number\">2</span> - ‘<span class=\"number\">2</span>’  </span><br><span class=\"line\"><span class=\"number\">1</span> - <span class=\"number\">22</span> - ‘<span class=\"number\">2</span>’  </span><br><span class=\"line\">(新增加的结果：)  </span><br><span class=\"line\">‘<span class=\"number\">1</span>’ - ‘<span class=\"number\">2</span>’ - ‘<span class=\"number\">22</span>’  </span><br><span class=\"line\">‘<span class=\"number\">12</span>’ - ‘<span class=\"number\">22</span>’  </span><br><span class=\"line\">前面三种是直接将<span class=\"number\">2</span>单独放在每种解码的后面，后面两种是将<span class=\"number\">2</span>与每种解码最后的值合并（如果合法的话），此题也即是考虑这些情况：  </span><br><span class=\"line\">定义dp[i]是nums前i个字符可以得到的解码种数，假设之前的字符串是abcx，现在新加入了y，则有以下<span class=\"number\">5</span>种情况：  </span><br><span class=\"line\"><span class=\"number\">1.</span>如果x==’<span class=\"number\">0</span>’，且y==’<span class=\"number\">0</span>’，无法解码，返回<span class=\"number\">0</span>；  </span><br><span class=\"line\"><span class=\"number\">2.</span>如果只有x==’<span class=\"number\">0</span>’，则y只能单独放在最后，不能与x合并(不能以<span class=\"number\">0</span>开头)，此时有：  </span><br><span class=\"line\">dp[i] = dp[i-<span class=\"number\">1</span>]  </span><br><span class=\"line\"><span class=\"number\">3.</span>如果只有y==’<span class=\"number\">0</span>’，则y不能单独放置，必须与x合并，并且如果合并结果大于<span class=\"number\">26</span>，返回<span class=\"number\">0</span>，否则有：  </span><br><span class=\"line\">dp[i] = dp[i-<span class=\"number\">2</span>]  </span><br><span class=\"line\"><span class=\"number\">4.</span>如果 xy&lt;=<span class=\"number\">26</span>:</span><br><span class=\"line\">则y可以“单独”放在abcx的每个解码结果之后后，并且如果abcx以x单独结尾，此时可以合并xy作为结尾，而这种解码种数就是abc的解码结果，此时有：  </span><br><span class=\"line\">dp[i+<span class=\"number\">1</span>] = dp[i] + dp[i-<span class=\"number\">1</span>]  </span><br><span class=\"line\"><span class=\"number\">5.</span>如果 xy&gt;<span class=\"number\">26</span>: 此时x又不能与y合并，y只能单独放在dp[i]的每一种情况的最后，此时有：  </span><br><span class=\"line\">dp[i+<span class=\"number\">1</span>] = dp[i]</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">numDecodings</span><span class=\"params\">(String s)</span> &#123;  </span><br><span class=\"line\">        <span class=\"type\">char</span>[] arr = s.toCharArray();  </span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[s.length()+<span class=\"number\">1</span>];  </span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;  </span><br><span class=\"line\">        dp[<span class=\"number\">1</span>] = arr[<span class=\"number\">0</span>]==<span class=\"string\">&#x27;0&#x27;</span>?<span class=\"number\">0</span>:<span class=\"number\">1</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.length()&lt;=<span class=\"number\">1</span>) <span class=\"keyword\">return</span> dp[<span class=\"number\">1</span>];  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=s.length();i++)&#123;  </span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> (arr[i-<span class=\"number\">2</span>]-<span class=\"string\">&#x27;0&#x27;</span>)*<span class=\"number\">10</span>+(arr[i-<span class=\"number\">1</span>]-<span class=\"string\">&#x27;0&#x27;</span>);  </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[i-<span class=\"number\">1</span>]==<span class=\"string\">&#x27;0&#x27;</span> &amp;&amp; arr[i-<span class=\"number\">2</span>]==<span class=\"string\">&#x27;0&#x27;</span>)&#123;  </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(arr[i-<span class=\"number\">2</span>]==<span class=\"string\">&#x27;0&#x27;</span>)&#123;  </span><br><span class=\"line\">                dp[i] = dp[i-<span class=\"number\">1</span>];  </span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(arr[i-<span class=\"number\">1</span>]==<span class=\"string\">&#x27;0&#x27;</span>)&#123;  </span><br><span class=\"line\">                <span class=\"keyword\">if</span>(n&gt;<span class=\"number\">26</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">                dp[i] = dp[i-<span class=\"number\">2</span>];  </span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(n&gt;<span class=\"number\">26</span>)&#123;  </span><br><span class=\"line\">                dp[i] = dp[i-<span class=\"number\">1</span>];  </span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;  </span><br><span class=\"line\">                dp[i] = dp[i-<span class=\"number\">1</span>]+dp[i-<span class=\"number\">2</span>];  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[dp.length-<span class=\"number\">1</span>];  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<h2 id=\"no.120-三角形的最小路径和\">NO.120 三角形的最小路径和<a title=\"#no.120-三角形的最小路径和\" href=\"#no.120-三角形的最小路径和\"></a></h2>\n<p>给定一个二维list，记作triangle，第i行包含i个元素，呈现一个三角形的结构，将从第一层走到最后一层经过的值的和算作路径长，求最短路径，每次只能走到左下或是右下的位置；<br>\n一看到这种问题，当然先想到动态规划，先建立一个二维数组，数组每个位置表示从第一层到这里的最短路径，问题不就迎刃而解了吗，下面是求解的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">minimumTotal</span><span class=\"params\">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> &#123;  </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> triangle.size();  </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">w</span> <span class=\"operator\">=</span> triangle.get(triangle.size()-<span class=\"number\">1</span>).size();  </span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[h][w];  </span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = triangle.get(<span class=\"number\">0</span>).get(<span class=\"number\">0</span>);  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;h;i++)&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;triangle.get(i).size();j++)&#123;  </span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">tmp</span> <span class=\"operator\">=</span> triangle.get(i).get(j);  </span><br><span class=\"line\">                <span class=\"keyword\">if</span>(j==<span class=\"number\">0</span>)&#123;dp[i][j] = tmp+dp[i-<span class=\"number\">1</span>][j];&#125;  </span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(j==triangle.get(i).size()-<span class=\"number\">1</span>)&#123;  </span><br><span class=\"line\">                    dp[i][j] = tmp+dp[i-<span class=\"number\">1</span>][j-<span class=\"number\">1</span>];  </span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;  </span><br><span class=\"line\">                    dp[i][j] = tmp+Math.min(dp[i-<span class=\"number\">1</span>][j-<span class=\"number\">1</span>],dp[i-<span class=\"number\">1</span>][j]);  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">min</span> <span class=\"operator\">=</span> Integer.MAX_VALUE;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> n:dp[h-<span class=\"number\">1</span>])&#123;min = Math.min(n,min);&#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> min;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>这里可以做一个改进：将自顶向下的遍历改为自底向上的遍历；因为每个三角形的每个位置都有左下角和右下角（除了最后一行），但是不一定都有左上角和右上角，自底向上的遍历省去了一些边界情况，还有就是第一行只有一个元素，遍历到顶的结果就是最终结果，而遍历到底的结果还要求最小值；<br>\n问题可以这么简单地做，但是题目又提出了一个进阶的要求：使用一维的数组；按行遍历三角形的时候一维数组怎么保存结果？每次都要用dp的值来计算并更新dp数组，这不就冲突了吗，其实仔细想想发现并没有，当在遍历三角形的第k行时，dp保存的是从最后一层到第k+1行每个位置的最短路径长，更新dp[i]会用到dp[i]和dp[i+1]以及triangle[k][i]，但是注意：更新完dp[i]后，后面计算dp[i+1]与dp[i]无关，因此可以在使用dp的同时更新dp，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">minimumTotal</span><span class=\"params\">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> &#123;  </span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[triangle.size()+<span class=\"number\">1</span>];  <span class=\"comment\">//把dp初始化为长度为triangle.size()+1的全0数组；  </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=triangle.size()-<span class=\"number\">1</span>;i&gt;=<span class=\"number\">0</span>;i--)&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;triangle.get(i).size();j++)&#123;  </span><br><span class=\"line\">                dp[j] = Math.min(dp[j],dp[j+<span class=\"number\">1</span>])+triangle.get(i).get(j);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[<span class=\"number\">0</span>];  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<h2 id=\"no.174-地下城游戏\">NO.174 地下城游戏<a title=\"#no.174-地下城游戏\" href=\"#no.174-地下城游戏\"></a></h2>\n<p>题目简单来说就是，给定一个数组，每个值表示到达当前位置需要消耗的生命值或是补充的生命值，当生命值小于等于0则死亡，求从数组的左上角走到右下角所需要的最小初始生命值；<br>\n这道题其实一看就知道是动态规划，但是好像又没那么简单，所以因为要求的是一条路径中的最小累加和，所以还用了两个数组来记录，最终越做越复杂。。。<br>\n其实这题的<strong>关键在于从右下角往左上角遍历</strong><br>\n，而dp[i][j]就表示从位置(i,j)到达右下角所需的最小生命值，最终算到dp[0][0]，而转移方程就是：</p>\n<p>dp[i,j] = max(1,min(dp[i+1][j],dp[i][j+1])-dungeon[i][j])</p>\n<p>因为就算路径上全是正数，也需要初始生命值为1；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">calculateMinimumHP</span><span class=\"params\">(<span class=\"type\">int</span>[][] dungeon)</span> &#123;  </span><br><span class=\"line\">        <span class=\"comment\">//dp[i][j]表示到达dungeon[i][j]所需的最小生命值  </span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> dungeon.length, w = dungeon[<span class=\"number\">0</span>].length;  </span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[h][w];  </span><br><span class=\"line\">        dp[h-<span class=\"number\">1</span>][w-<span class=\"number\">1</span>] = dungeon[h-<span class=\"number\">1</span>][w-<span class=\"number\">1</span>]&gt;<span class=\"number\">0</span>?<span class=\"number\">1</span>:<span class=\"number\">1</span>-dungeon[h-<span class=\"number\">1</span>][w-<span class=\"number\">1</span>];  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=h-<span class=\"number\">2</span>;i&gt;=<span class=\"number\">0</span>;i--)&#123;  </span><br><span class=\"line\">            dp[i][w-<span class=\"number\">1</span>] = Math.max(<span class=\"number\">1</span>,dp[i+<span class=\"number\">1</span>][w-<span class=\"number\">1</span>]-dungeon[i][w-<span class=\"number\">1</span>]);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=w-<span class=\"number\">2</span>;j&gt;=<span class=\"number\">0</span>;j--)&#123;  </span><br><span class=\"line\">            dp[h-<span class=\"number\">1</span>][j] = Math.max(<span class=\"number\">1</span>,dp[h-<span class=\"number\">1</span>][j+<span class=\"number\">1</span>]-dungeon[h-<span class=\"number\">1</span>][j]);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=h-<span class=\"number\">2</span>;i&gt;=<span class=\"number\">0</span>;i--)&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=w-<span class=\"number\">2</span>;j&gt;=<span class=\"number\">0</span>;j--)&#123;  </span><br><span class=\"line\">                dp[i][j] = Math.max(<span class=\"number\">1</span>,Math.min(dp[i+<span class=\"number\">1</span>][j],dp[i][j+<span class=\"number\">1</span>])-dungeon[i][j]);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>];  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<h2 id=\"no.221-最大正方形\">NO.221 最大正方形<a title=\"#no.221-最大正方形\" href=\"#no.221-最大正方形\"></a></h2>\n<p>给定一个包含0和1二维矩阵，求出其中由1组成的最大正方形的面积；<br>\n做过很多这样的01矩阵问题，有的是把1当作岛屿，求岛屿面积，有的是求每个1到最近的0的距离……这类问题很多是用DFS或BFS，而这题是求正方形的面积，DFS不可行，而可以由小正方形面积求出大正方形的面积，因此用动态规划求解；<br>\n定义dp[i][j]是以matrix[i][j]作为右下角的最大正方形的边长长度则:<br>\nif dp[i][j]==0 dp[i][j] = 0<br>\nif dp[i][j]==1 &amp;&amp; matrix[i-k][j]&gt;0 &amp;&amp; matrix[i-k][j]&gt;0; k=1,2,…,dp[i-1][i-2]:<br>\ndp[i][j] = dp[i-1][j-1]+1<br>\nelse:<br>\ndp[i][j] = 1<br>\n这样的话对于就要遍历求边长，如：</p>\n<p>\\begin{matrix} 1 &amp; 1 &amp; 1 &amp; 0 \\\\ 1 &amp; 1 &amp; 1 &amp; 1 \\\\ 1 &amp; 1 &amp; 1 &amp; 1 \\\\ 1 &amp; 0 &amp; 1<br>\n&amp; 1 \\end{matrix}</p>\n<p>在计算dp[3][3]的时候要看第4行和第4列是否全为1，否则边长缩短，求解的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maximalSquare</span><span class=\"params\">(<span class=\"type\">char</span>[][] matrix)</span> &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(matrix.length==<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[matrix.length][matrix[<span class=\"number\">0</span>].length];  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;matrix.length;i++)&#123;  </span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = matrix[i][<span class=\"number\">0</span>]-<span class=\"string\">&#x27;0&#x27;</span>;  </span><br><span class=\"line\">            result = Math.max(result,dp[i][<span class=\"number\">0</span>]);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;matrix[<span class=\"number\">0</span>].length;j++)&#123;  </span><br><span class=\"line\">            dp[<span class=\"number\">0</span>][j] = matrix[<span class=\"number\">0</span>][j]-<span class=\"string\">&#x27;0&#x27;</span>;  </span><br><span class=\"line\">            result = Math.max(result,dp[<span class=\"number\">0</span>][j]);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;matrix.length;i++)&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;matrix[<span class=\"number\">0</span>].length;j++)&#123;  </span><br><span class=\"line\">                <span class=\"keyword\">if</span>(matrix[i][j]!=<span class=\"string\">&#x27;1&#x27;</span>) <span class=\"keyword\">continue</span>;  </span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> x=<span class=\"number\">1</span>;x&lt;=dp[i-<span class=\"number\">1</span>][j-<span class=\"number\">1</span>];x++)&#123;  </span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(dp[i-x][j]&gt;<span class=\"number\">0</span> &amp;&amp; dp[i][j-x]&gt;<span class=\"number\">0</span>)&#123;  </span><br><span class=\"line\">                        len++;  </span><br><span class=\"line\">                    &#125;<span class=\"keyword\">else</span>&#123;<span class=\"keyword\">break</span>;&#125;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">                dp[i][j] = len+<span class=\"number\">1</span>;  </span><br><span class=\"line\">                result = Math.max(result,dp[i][j]);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result*result;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>可以对方法进行改进，dp依旧使用上面的定义，但是更新dp[i][j]时候不用遍历寻找最大边长，而是取左上角、左边、上面的均填充为1的最大面积：<br>\ndp[i][j] = Min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])<br>\n求解的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maximalSquare</span><span class=\"params\">(<span class=\"type\">char</span>[][] matrix)</span> &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(matrix.length==<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> matrix.length, w = matrix[<span class=\"number\">0</span>].length;  </span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[h+<span class=\"number\">1</span>][w+<span class=\"number\">1</span>];  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=h;i++)&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=w;j++)&#123;  </span><br><span class=\"line\">                <span class=\"keyword\">if</span>(matrix[i-<span class=\"number\">1</span>][j-<span class=\"number\">1</span>]==<span class=\"string\">&#x27;0&#x27;</span>) <span class=\"keyword\">continue</span>;  </span><br><span class=\"line\">                dp[i][j] = <span class=\"number\">1</span>+Math.min(dp[i-<span class=\"number\">1</span>][j-<span class=\"number\">1</span>],Math.min(dp[i-<span class=\"number\">1</span>][j],dp[i][j-<span class=\"number\">1</span>]));  </span><br><span class=\"line\">                result = Math.max(result,dp[i][j]);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result*result;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<h2 id=\"no.264-丑数ii\">NO.264 丑数II<a title=\"#no.264-丑数ii\" href=\"#no.264-丑数ii\"></a></h2>\n<p>丑数是因数里只包含2，3，5的正整数，认为1也是丑数，求第n个丑数；<br>\n第一眼看到就觉得这是一个一般的动态规划问题，dp[i]可以由dp[i/2],dp[i/3],dp[i/5]求得（如果可以整除），但是如果用数组，事先又不知道数组长度，因为有非丑数，如果用ArrayList或HashSet又会超时，难办。。。<br>\n有一个很妙但是又感觉很普通（为什么自己没有想到）的方法：三指针，使用三个指针，每次取三个指针分别乘以2，3，5中的最小结果，即是下一个丑数，然后将取得最小结果的指针后移一位，感觉像是上面的想法倒过来实现，只是每次要保证得到的是最小的丑数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">nthUglyNumber</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;  </span><br><span class=\"line\">        <span class=\"comment\">// if(n==1) return 1;  </span></span><br><span class=\"line\">        <span class=\"comment\">// int count = 1, i = 2;  </span></span><br><span class=\"line\">        <span class=\"comment\">// int[] factor = &#123;2,3,5&#125;;  </span></span><br><span class=\"line\">        <span class=\"comment\">// List&lt;Integer&gt; l = new ArrayList&lt;&gt;();  </span></span><br><span class=\"line\">        <span class=\"comment\">// l.add(1);  </span></span><br><span class=\"line\">        <span class=\"comment\">// l.add(1);  </span></span><br><span class=\"line\">        <span class=\"comment\">// while(count&lt;n)&#123;  </span></span><br><span class=\"line\">        <span class=\"comment\">//     l.add(0);  </span></span><br><span class=\"line\">        <span class=\"comment\">//     for(int num: factor)&#123;  </span></span><br><span class=\"line\">        <span class=\"comment\">//         if(i&gt;=num &amp;&amp; i%num==0 &amp;&amp; l.get(i/num)==1)&#123;  </span></span><br><span class=\"line\">        <span class=\"comment\">//             l.set(l.size()-1,1);  </span></span><br><span class=\"line\">        <span class=\"comment\">//             count++;  </span></span><br><span class=\"line\">        <span class=\"comment\">//             break;  </span></span><br><span class=\"line\">        <span class=\"comment\">//         &#125;  </span></span><br><span class=\"line\">        <span class=\"comment\">//     &#125;  </span></span><br><span class=\"line\">        <span class=\"comment\">//     i++;  </span></span><br><span class=\"line\">        <span class=\"comment\">// &#125;  </span></span><br><span class=\"line\">        <span class=\"comment\">// return l.size()-1;  </span></span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"type\">int</span> a=<span class=\"number\">0</span>, b=<span class=\"number\">0</span>, c=<span class=\"number\">0</span>;  </span><br><span class=\"line\">        <span class=\"type\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n];  </span><br><span class=\"line\">        arr[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;n;i++)&#123;  </span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">ugly</span> <span class=\"operator\">=</span> Math.min(arr[a]*<span class=\"number\">2</span>,Math.min(arr[b]*<span class=\"number\">3</span>,arr[c]*<span class=\"number\">5</span>));  </span><br><span class=\"line\">            arr[i] = ugly;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[i]==arr[a]*<span class=\"number\">2</span>) a++;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[i]==arr[b]*<span class=\"number\">3</span>) b++;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[i]==arr[c]*<span class=\"number\">5</span>) c++;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> arr[n-<span class=\"number\">1</span>];  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<h2 id=\"no.300-最长上升子序列\">NO.300 最长上升子序列<a title=\"#no.300-最长上升子序列\" href=\"#no.300-最长上升子序列\"></a></h2>\n<p>给定一个无序的整数数组，找出其中最长的上升子序列的长度，上升子序列不要求连续；<br>\n动态规划：定义dp[i]表示前i个值可以组成的最长上升序列的长度，然后求dp[i+1]的时候用k遍历前面i个dp值，取nums[k]&lt;nums[i+1]中dp[k]的最大值再加1，时间复杂度是O(n^2):</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">lengthOfLIS</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.length&lt;=<span class=\"number\">1</span>) <span class=\"keyword\">return</span> nums.length;  </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">max</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums.length];  </span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;nums.length;i++)&#123;  </span><br><span class=\"line\">            dp[i] = <span class=\"number\">1</span>;  </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=i-<span class=\"number\">1</span>;j&gt;=<span class=\"number\">0</span>;j--)&#123;  </span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums[j]&lt;nums[i])&#123;  </span><br><span class=\"line\">                    dp[i] = Math.max(dp[i],dp[j]+<span class=\"number\">1</span>);  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            max = Math.max(max,dp[i]);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>还有一个更好的方法：贪心算法+二分查找；上面的方法可以使用二分查找改善时间复杂度因为tmp是递增的，因此可以使用二分查找得到所插入的位置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">lengthOfLIS</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.length&lt;=<span class=\"number\">1</span>) <span class=\"keyword\">return</span> nums.length;  </span><br><span class=\"line\">        <span class=\"type\">int</span>[] tmp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums.length];  </span><br><span class=\"line\">        tmp[<span class=\"number\">0</span>] = nums[<span class=\"number\">0</span>];  </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> n: nums)&#123;  </span><br><span class=\"line\">            <span class=\"type\">int</span> l=<span class=\"number\">0</span>, r=len;  </span><br><span class=\"line\">            <span class=\"keyword\">while</span>(l&lt;r)&#123;  </span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> (l+r)/<span class=\"number\">2</span>;  </span><br><span class=\"line\">                <span class=\"keyword\">if</span>(tmp[m]&gt;=n)&#123;  </span><br><span class=\"line\">                    r = m;  </span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;l = m+<span class=\"number\">1</span>;&#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            tmp[l] = n;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(l==len) len++;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> len;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<h2 id=\"no.322-零钱兑换\">NO.322 零钱兑换<a title=\"#no.322-零钱兑换\" href=\"#no.322-零钱兑换\"></a></h2>\n<p>给定一些不同面额的硬币coins和一个总金额amount，将总金额兑换成数量最少的硬币，如果不能兑换返回-1；<br>\n用动态规划求解的话就很简单，但前提是想得到，先建立一个dp数组保存之前计算的结果，定义dp[i]为金额为i时兑换零钱的最小数量，由此，对于每一个面额c的零钱有：<br>\n<code>dp[i] = dp[i-c]+1, if dp[i-c]!=-1</code><br>\n基于以上的分析，只需要从头遍历dp数组，同时修改dp[i]为兑换零钱的最小数量，最终dp[amount]就是答案：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">coinChange</span><span class=\"params\">(<span class=\"type\">int</span>[] coins, <span class=\"type\">int</span> amount)</span> &#123;  </span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[amount+<span class=\"number\">1</span>];  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=amount;i++)&#123;  </span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">min</span> <span class=\"operator\">=</span> Integer.MAX_VALUE;  </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> c: coins)&#123;  </span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i&gt;=c &amp;&amp; dp[i-c]!=-<span class=\"number\">1</span>)&#123;  </span><br><span class=\"line\">                    min = Math.min(min,dp[i-c]+<span class=\"number\">1</span>);  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            dp[i] = min!=Integer.MAX_VALUE?min:-<span class=\"number\">1</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[amount];  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<h2 id=\"no.368-最大整除子集\">NO.368 最大整除子集<a title=\"#no.368-最大整除子集\" href=\"#no.368-最大整除子集\"></a></h2>\n<p>非常眼熟但是没做出来的题，给定一个数组，找出其最大的子数组且该子数组满足：任意的两个元素a,b有a%b==0或b%a==0；<br>\n一开始而没想到用什么方法就又想用DFS，结果又是超时，迫于无奈看了大佬的解法，感觉自己真的变傻了。<strong>第一个问题</strong><br>\n在于自己把a%b==0或b%a==0想的太复杂，为什么要拿两个数来试这两个条件？如果a&gt;b&gt;0，只可能a%b==0,b%a一定不是0，所以只要对数组排序，使其从小到大排列，然后直接用后面的数除前面的数就行；<strong>第二个问题</strong><br>\n是以为每加入一个数都要和原数组中每个数都判断一下，但是如果a&gt;b&gt;c,a%b==0,b%c==0,不就有a%c==0吗；<br>\n因此可以定义dp[i]表示nums前i个数可以组成的最大整除子集的大小，在计算dp[i]的时候，遍历nums的0~i-1为j，如果nums[i]%nums[j]==0，则表示可以在dp[j]的最大整除子集中加入nums[i]，即dp[i]=dp[j]+1，在遍历过程中取dp[i]的最大值：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title function_\">largestDivisibleSubset</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span>&#123;   </span><br><span class=\"line\">        List&lt;Integer&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.length==<span class=\"number\">0</span>) <span class=\"keyword\">return</span> result;  </span><br><span class=\"line\">        Arrays.sort(nums);  </span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums.length];  </span><br><span class=\"line\">        Arrays.fill(dp,<span class=\"number\">1</span>);  </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, max = <span class=\"number\">1</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;dp.length;i++)&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;i;j++)&#123;  </span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums[i]%nums[j]==<span class=\"number\">0</span>)&#123;  </span><br><span class=\"line\">                    dp[i] = Math.max(dp[i],dp[j]+<span class=\"number\">1</span>);  </span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(dp[i]&gt;max)&#123;  </span><br><span class=\"line\">                        max = dp[i];  </span><br><span class=\"line\">                        p = i;  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k=p;k&gt;=<span class=\"number\">0</span>;k--)&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[p]%nums[k]==<span class=\"number\">0</span> &amp;&amp; dp[k]==max)&#123;  </span><br><span class=\"line\">                result.add(nums[k]);  </span><br><span class=\"line\">                max--;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<h2 id=\"no.375-猜数字得大小ii\">NO.375 猜数字得大小II<a title=\"#no.375-猜数字得大小ii\" href=\"#no.375-猜数字得大小ii\"></a></h2>\n<p>给定一个正整数n，可以从1~n之间任选一个数，另一个人来猜这个数，如果猜的是x且猜错则需要支付金额为x的现金，猜对所选的数则赢得游戏，问题要求的是至少有多少金额才能保证赢得游戏？<br>\n一开始以为每次取二分是最好的选择，但是错了，比如：<code>1,2,3,4,5</code>，每次猜二分的结果则最大金额为7，但其实可以先猜2，再猜4，这样只要有金额为6就可以保证获胜；<br>\n接着想到了动态规划，我每次选倒数第四个i-4，如果小了的话就直接猜倒数第二个i-2，如果大了，i-4前面的结果就是dp[i-5]，这里的倒数第四个可以递推为7,15,31…但是这样做可以正确得到125之前的结果，后面就错了，不知道为啥；<br>\n其实自己只想到了一般，i-4前的结果是dp[i-5]，那i-4之后的结果不就是dp[i-3]吗，但是怎么更新前后的dp值，这里就需要一个二维dp数组，定义dp[i][j]表示在i~j中确保赢得最小金额，则对于任意x在i~j中，有dp[i][j]<br>\n= min(max(dp[i][x-1],dp[x+1][j])+x)，重点是<strong>先更新dp[i][i+1]</strong> ，<strong>再更新dp[i][i+2]</strong><br>\n…最后就可以得到结果dp[0][n]；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getMoneyAmount</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;  </span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n+<span class=\"number\">1</span>][n+<span class=\"number\">1</span>];  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k=<span class=\"number\">1</span>;k&lt;n;k++)&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i+k&lt;=n;i++)&#123;  </span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">min</span> <span class=\"operator\">=</span> Integer.MAX_VALUE;  </span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> x=i;x&lt;i+k;x++)&#123;  </span><br><span class=\"line\">                    min = Math.min(min,Math.max(dp[i][x-<span class=\"number\">1</span>],dp[x+<span class=\"number\">1</span>][i+k])+x);  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">                dp[i][i+k] = min;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[<span class=\"number\">1</span>][n];  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<h2 id=\"no.376-摆动序列\">NO.376 摆动序列<a title=\"#no.376-摆动序列\" href=\"#no.376-摆动序列\"></a></h2>\n<p>连续数字之间的差严格在正负之间交替的序列称为摆动序列，给定一个数组，求摆动序列的最大长度，可以不要求序列连续，但是要保持原始顺序；<br>\n一开始的想法是遍历每次比较三个数：<code>x,y,z</code>，tmp指向x，如果这三个数是摆动序列，则更新tmp为y，否则不更新，然后y，z向后遍历，每次更新摆动序列长度加1，但是长度的初始值1还是2有点麻烦，最后结果也超过了100%；<br>\n大佬的解法太妙了，有点像股票问题的做法，用up记录nums前面上升的最大长度，用down记录nums前面下降的最大长度，然后遍历过程中交替更行up和down；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">wiggleMaxLength</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;  </span><br><span class=\"line\">        <span class=\"comment\">// if(nums.length&lt;=1) return nums.length;  </span></span><br><span class=\"line\">        <span class=\"comment\">// if(nums.length==2) return nums[0]==nums[1]?1:2;  </span></span><br><span class=\"line\">        <span class=\"comment\">// int tmp = nums[0];  </span></span><br><span class=\"line\">        <span class=\"comment\">// int len = nums[0]==nums[1]?1:2;  </span></span><br><span class=\"line\">        <span class=\"comment\">// for(int i=2;i&lt;nums.length;i++)&#123;  </span></span><br><span class=\"line\">        <span class=\"comment\">//     if(nums[i]!=tmp) len = Math.max(len,2);  </span></span><br><span class=\"line\">        <span class=\"comment\">//     if((nums[i-1]-tmp)*(nums[i]-nums[i-1])&lt;0)&#123;  </span></span><br><span class=\"line\">        <span class=\"comment\">//         len++;  </span></span><br><span class=\"line\">        <span class=\"comment\">//         tmp = nums[i-1];  </span></span><br><span class=\"line\">        <span class=\"comment\">//     &#125;  </span></span><br><span class=\"line\">        <span class=\"comment\">// &#125;  </span></span><br><span class=\"line\">        <span class=\"comment\">// return len;  </span></span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.length==<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">up</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>, down = <span class=\"number\">1</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;nums.length;i++)&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i]&gt;nums[i-<span class=\"number\">1</span>]) up = down+<span class=\"number\">1</span>;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i]&lt;nums[i-<span class=\"number\">1</span>]) down = up+<span class=\"number\">1</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.max(up,down);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<h2 id=\"no.416-分割等和子集\">NO.416 分割等和子集<a title=\"#no.416-分割等和子集\" href=\"#no.416-分割等和子集\"></a></h2>\n<p>给定一个只包含正整数的数组，是否可以将数组分为两部分，两部分的和相等；<br>\n首先可以用DFS来做，其次也可以用动态规划，一开始的错误思路是想令dp[i]表示nums中是否有和为i的组合，这没有问题但是更新的思路有问题，如果遍历dp数组，然后更新每一位，那dp[i]怎么计算？看dp[i-num]是否为true？这是可以重复使用nums中每个元素的情况，因为dp[i-num]中可能已经包含了num；<br>\n这里换换思路，不是遍历dp更新每一位，而是<strong>遍历nums，每次更新dp</strong><br>\n，也就是每次加入一个num，然后记录dp中哪些和是可以得到的，可以定义dp[nums.length][target],也可以定义为一维数组：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">canPartition</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;  </span><br><span class=\"line\">    <span class=\"comment\">//     int sum = 0;  </span></span><br><span class=\"line\">    <span class=\"comment\">//     for(int n: nums) sum += n;  </span></span><br><span class=\"line\">    <span class=\"comment\">//     if(sum%2!=0) return false;  </span></span><br><span class=\"line\">    <span class=\"comment\">//     for(int n: nums)&#123;  </span></span><br><span class=\"line\">    <span class=\"comment\">//         if(n&gt;sum/2) return false;  </span></span><br><span class=\"line\">    <span class=\"comment\">//         if(n==sum/2) return true;  </span></span><br><span class=\"line\">    <span class=\"comment\">//     &#125;  </span></span><br><span class=\"line\">    <span class=\"comment\">//     Arrays.sort(nums);  </span></span><br><span class=\"line\">    <span class=\"comment\">//     return dfs(nums,sum/2,nums.length-1);  </span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;  </span></span><br><span class=\"line\">    <span class=\"comment\">// public boolean dfs(int[] nums,int target,int i)&#123;  </span></span><br><span class=\"line\">    <span class=\"comment\">//     boolean sign = false;  </span></span><br><span class=\"line\">    <span class=\"comment\">//     if(i&gt;nums.length || target&lt;0) return false;  </span></span><br><span class=\"line\">    <span class=\"comment\">//     if(target==0) return true;  </span></span><br><span class=\"line\">    <span class=\"comment\">//     for(int k=i;k&gt;=0;k--)&#123;  </span></span><br><span class=\"line\">    <span class=\"comment\">//         sign = sign || dfs(nums,target-nums[k],k-1);  </span></span><br><span class=\"line\">    <span class=\"comment\">//     &#125;  </span></span><br><span class=\"line\">    <span class=\"comment\">//     return sign;  </span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;  </span></span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> n: nums) sum += n;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sum%<span class=\"number\">2</span>!=<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">target</span> <span class=\"operator\">=</span> sum/<span class=\"number\">2</span>;  </span><br><span class=\"line\">        <span class=\"type\">boolean</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[target+<span class=\"number\">1</span>];  </span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"literal\">true</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> n: nums)&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=target;i&gt;=<span class=\"number\">0</span>;i--)&#123;  </span><br><span class=\"line\">                <span class=\"keyword\">if</span>(n==i || (i-n&gt;=<span class=\"number\">0</span> &amp;&amp; dp[i-n]))&#123;  </span><br><span class=\"line\">                    dp[i] = <span class=\"literal\">true</span>;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[target];  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<h2 id=\"no.474-一和零\">NO.474 一和零<a title=\"#no.474-一和零\" href=\"#no.474-一和零\"></a></h2>\n<p>给定一个字符串数组和最大的0和1的个数m,n，数组中每个字符串只包含0和1，求用m个0和n个1可以组成数组中最多几个字符串(不重复)；<br>\n令dp[i][j]表示用i个0和j个1可以组成的字符串数量，遍历字符串数组，每加入一个字符串更新一次dp数组，最后的结果就是dp[m][n]；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">findMaxForm</span><span class=\"params\">(String[] strs, <span class=\"type\">int</span> m, <span class=\"type\">int</span> n)</span> &#123;  </span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[m+<span class=\"number\">1</span>][n+<span class=\"number\">1</span>];  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;strs.length;i++)&#123;  </span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, b = <span class=\"number\">0</span>;  </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">char</span> c: strs[i].toCharArray())&#123;  </span><br><span class=\"line\">                <span class=\"keyword\">if</span>(c==<span class=\"string\">&#x27;0&#x27;</span>)&#123;a++;&#125;  </span><br><span class=\"line\">                <span class=\"keyword\">else</span>&#123;b++;&#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=m;j&gt;=a;j--)&#123;  </span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k=n;k&gt;=b;k--)&#123;  </span><br><span class=\"line\">                    dp[j][k] = Math.max(dp[j][k],dp[j-a][k-b]+<span class=\"number\">1</span>);  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m][n];  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<h2 id=\"no.494-目标和\">NO.494 目标和<a title=\"#no.494-目标和\" href=\"#no.494-目标和\"></a></h2>\n<p>给定一个数组nums和一个目标数S，可以对数组中的每个数进行加或减，如果可以得到结果为目标数则是一个符合要求的方法，求方法的总数；<br>\n首先这道题可以用暴力枚举来做，列出所有的情况，也就是回溯法，但是这样比较耗时；<br>\n使用动态规划来求解，定义dp数组的dp[i][j]表示nums的前i个数可以组成结果为j的方法数，而这个结果j是在[-sum,sum]内，sum是数组nums的和，因此dp数组的维度是[nums.length][sum*2+1]，最后得到的dp[nums.length-1]就是对nums中所有数进行加减可能得到的所有结果及其方法数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">findTargetSumWays</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> S)</span> &#123;  </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, result = <span class=\"number\">0</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> n: nums) sum += n;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sum&lt;S) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums.length][sum*<span class=\"number\">2</span>+<span class=\"number\">1</span>];  </span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][sum-nums[<span class=\"number\">0</span>]]++;  </span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][sum+nums[<span class=\"number\">0</span>]]++;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;nums.length;i++)&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;sum*<span class=\"number\">2</span>+<span class=\"number\">1</span>;j++)&#123;  </span><br><span class=\"line\">                <span class=\"keyword\">if</span>(j-nums[i]&gt;=<span class=\"number\">0</span>)&#123;  </span><br><span class=\"line\">                    dp[i][j] += dp[i-<span class=\"number\">1</span>][j-nums[i]];  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">                <span class=\"keyword\">if</span>(j+nums[i]&lt;sum*<span class=\"number\">2</span>+<span class=\"number\">1</span>)&#123;  </span><br><span class=\"line\">                    dp[i][j] += dp[i-<span class=\"number\">1</span>][j+nums[i]];  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[nums.length-<span class=\"number\">1</span>][S+sum];  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<h2 id=\"no.518-零钱兑换ii\">NO.518 零钱兑换II<a title=\"#no.518-零钱兑换ii\" href=\"#no.518-零钱兑换ii\"></a></h2>\n<p>给定一个数组coins表示不同面值的硬币，可以重复使用，计算面额amount可以兑换硬币的方式，不同顺序的兑换看作同一种；<br>\n之前零钱兑换的问题只需要计算最少的硬币数量，这里要求所有的兑换方式，可以定义dp[i][j]表示面额为i时使用前j种硬币兑换的方式数，计算方式可以看作每加入一种硬币j计算一次在前j种硬币下dp[i]种每种金额的兑换种数，即：</p>\n<p>dp[i] = dp[i]+dp[i-coin]</p>\n<p><img src=\"images/Java_DynamicProgramming/2.jpg\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">change</span><span class=\"params\">(<span class=\"type\">int</span> amount, <span class=\"type\">int</span>[] coins)</span> &#123;  </span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[amount+<span class=\"number\">1</span>];  </span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> coin: coins)&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=coin;i&lt;=amount;i++)&#123;  </span><br><span class=\"line\">                dp[i] += dp[i-coin];  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[amount];  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<h2 id=\"no.576-出界的路径数\">NO.576 出界的路径数<a title=\"#no.576-出界的路径数\" href=\"#no.576-出界的路径数\"></a></h2>\n<p>给出一个矩阵的大小，一个最大步数，一个位置坐标，从这个坐标开始，每次可以向上下左右走一步，走出矩阵边界则是一条出界路径，求所有的出界路径数；<br>\n又是一道DFS解出来超时再用动态规划求解的题目，定义在第k步时的dp[i][j]是从位置[i,j]走出界的路径数，因此每一步都会有一个dp矩阵，且有：<br>\n第k+1步中，dp[i][j]为上下左右四个方向的路径数的和，如果[i,j]的下一步出界，则路径数加1：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">findPaths</span><span class=\"params\">(<span class=\"type\">int</span> m, <span class=\"type\">int</span> n, <span class=\"type\">int</span> N, <span class=\"type\">int</span> i, <span class=\"type\">int</span> j)</span> &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(N==<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">mod</span> <span class=\"operator\">=</span> <span class=\"number\">1000000007</span>;  </span><br><span class=\"line\">        <span class=\"type\">int</span>[][] direct = &#123;&#123;<span class=\"number\">1</span>,<span class=\"number\">0</span>&#125;,&#123;-<span class=\"number\">1</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>&#125;,&#123;<span class=\"number\">0</span>,-<span class=\"number\">1</span>&#125;&#125;;  </span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[m][n];  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k=<span class=\"number\">0</span>;k&lt;N;k++)&#123;  </span><br><span class=\"line\">            <span class=\"type\">int</span>[][] tmp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[m][n];  </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> x=<span class=\"number\">0</span>;x&lt;m;x++)&#123;  </span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> y=<span class=\"number\">0</span>;y&lt;n;y++)&#123;  </span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"type\">int</span>[] d: direct)&#123;  </span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(x+d[<span class=\"number\">0</span>]&lt;<span class=\"number\">0</span> || x+d[<span class=\"number\">0</span>]&gt;=m || y+d[<span class=\"number\">1</span>]&lt;<span class=\"number\">0</span> || y+d[<span class=\"number\">1</span>]&gt;=n)&#123;  </span><br><span class=\"line\">                            tmp[x][y]++;  </span><br><span class=\"line\">                        &#125;<span class=\"keyword\">else</span>&#123;  </span><br><span class=\"line\">                            tmp[x][y] = (tmp[x][y]+dp[x+d[<span class=\"number\">0</span>]][y+d[<span class=\"number\">1</span>]])%mod;  </span><br><span class=\"line\">                        &#125;  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            dp = tmp;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[i][j];  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<h2 id=\"no.718-最长重复数组问题\">NO.718 最长重复数组问题<a title=\"#no.718-最长重复数组问题\" href=\"#no.718-最长重复数组问题\"></a></h2>\n<p>题目非常容易理解，给定两个数组，找出其中最长的公共数组，要求公共数组是连续的，一开始看到这道题的时候没有想到用dp的方法，但是也没有想到其他什么方法。。。<br>\n以两个数组为例：<code>A=[1,2,3,2,1],B=[3,2,1,4,7]</code>，可以使用一个dp数组来保存每次计算的结果，dp[i][j]表示数组A[:i]和B[:j]的最长公共数组的长度，注意这里的公共数组要求是以A[i]和B[j]结尾，因此当A[i]!=B[j]时，令dp[i][j]=0，如果A[i]==B[j]，令dp[i][j]=dp[i-1][j-1]+1，最终只要找到dp数组中的最大值就是结果；<br>\n可以将dp数组的维度加1以省略初始化的步骤，但是要注意一下索引值：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">findLength</span><span class=\"params\">(<span class=\"type\">int</span>[] A, <span class=\"type\">int</span>[] B)</span> &#123;  </span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[A.length+<span class=\"number\">1</span>][B.length+<span class=\"number\">1</span>];  </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=A.length;i++)&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=B.length;j++)&#123;  </span><br><span class=\"line\">                <span class=\"keyword\">if</span>(A[i-<span class=\"number\">1</span>]==B[j-<span class=\"number\">1</span>])&#123;  </span><br><span class=\"line\">                    dp[i][j] = dp[i-<span class=\"number\">1</span>][j-<span class=\"number\">1</span>]+<span class=\"number\">1</span>;  </span><br><span class=\"line\">                    result = Math.max(result,dp[i][j]);  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n","prev":{"title":"学习笔记：MySQL数据库","link":"2020/03/16/blog/MySQL_learning"},"next":{"title":"Java-BFS与DFS","link":"2020/03/08/blog/Java_DFS_Backtrack"},"plink":"https://qfzack.github.io/2020/03/09/blog/Java_DynamicProgramming/","toc":[{"id":"2020-3-29-关于动态规划的一些总结","title":"2020-3-29 关于动态规划的一些总结","index":"1"},{"id":"1.股票问题","title":"1.股票问题","index":"2","children":[{"id":"no.121-买卖股票的最佳时机","title":"NO.121 买卖股票的最佳时机","index":"2.1"},{"id":"no.122-买卖股票的最佳时机ii","title":"NO.122 买卖股票的最佳时机II","index":"2.2"},{"id":"no.123-买卖股票的最佳时机iii","title":"NO.123 买卖股票的最佳时机III","index":"2.3"},{"id":"no.188-买卖股票的最佳时机iv","title":"NO.188 买卖股票的最佳时机IV","index":"2.4"},{"id":"no.309-最佳买卖股票时机含冷冻期","title":"NO.309 最佳买卖股票时机含冷冻期","index":"2.5"}]},{"id":"2.打家劫舍","title":"2.打家劫舍","index":"3","children":[{"id":"no.198-打家劫舍","title":"NO.198 打家劫舍","index":"3.1"},{"id":"no.213-打家劫舍ii","title":"NO.213 打家劫舍II","index":"3.2"},{"id":"no.337-打家劫舍iii","title":"NO.337 打家劫舍III","index":"3.3"}]},{"id":"3.字符串公共子序列问题","title":"3.字符串公共子序列问题","index":"4","children":[{"id":"no.583-两个字符串的删除操作","title":"NO.583 两个字符串的删除操作","index":"4.1"},{"id":"no.712-两个字符串的最小ascii删除和","title":"NO.712 两个字符串的最小ASCII删除和","index":"4.2"},{"id":"no.1035-不相交的线","title":"NO.1035 不相交的线","index":"4.3"},{"id":"no.72-编辑距离","title":"NO.72 编辑距离","index":"4.4"},{"id":"no.120-三角形的最小路径和","title":"NO.120 三角形的最小路径和","index":"4.5"},{"id":"no.174-地下城游戏","title":"NO.174 地下城游戏","index":"4.6"},{"id":"no.221-最大正方形","title":"NO.221 最大正方形","index":"4.7"},{"id":"no.264-丑数ii","title":"NO.264 丑数II","index":"4.8"},{"id":"no.300-最长上升子序列","title":"NO.300 最长上升子序列","index":"4.9"},{"id":"no.322-零钱兑换","title":"NO.322 零钱兑换","index":"4.10"},{"id":"no.368-最大整除子集","title":"NO.368 最大整除子集","index":"4.11"},{"id":"no.375-猜数字得大小ii","title":"NO.375 猜数字得大小II","index":"4.12"},{"id":"no.376-摆动序列","title":"NO.376 摆动序列","index":"4.13"},{"id":"no.416-分割等和子集","title":"NO.416 分割等和子集","index":"4.14"},{"id":"no.474-一和零","title":"NO.474 一和零","index":"4.15"},{"id":"no.494-目标和","title":"NO.494 目标和","index":"4.16"},{"id":"no.518-零钱兑换ii","title":"NO.518 零钱兑换II","index":"4.17"},{"id":"no.576-出界的路径数","title":"NO.576 出界的路径数","index":"4.18"},{"id":"no.718-最长重复数组问题","title":"NO.718 最长重复数组问题","index":"4.19"}]}],"reading_time":"11715 words in 78 min"}