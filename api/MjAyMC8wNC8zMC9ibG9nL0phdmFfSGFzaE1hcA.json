{"title":"Java集合-初读HashMap源码","date":"2020-04-29T21:00:00.000Z","date_formatted":{"ll":"Apr 30, 2020","L":"04/30/2020","MM-DD":"04-30"},"author":"Qingfeng Zhang","link":"2020/04/30/blog/Java_HashMap","categories":["Data Structure","Java"],"updated":"2025-04-12T14:12:03.391Z","content":"<p>哈希表(散列表)是根据设定的哈希函数和冲突处理方法把一组关键字映射到一个有限的地址空间，存放关键字及其对应的值的表称为哈希表或散列，哈希冲突主要取决于：哈希函数、冲突处理方法、负载因子的大小；常用的哈希冲突解决方法：<br>\n1.开放地址法：线性探测、二次探测<br>\n2.链地址法<br>\n3.再哈希法<br>\n4.建立公共溢出区域<br>\nHashMap解决哈希冲突中的链地址法就是将数组和链表结合在一起，发挥两者的优势；HashMap继承了AbstractMap类，同时实现了Map等多个接口；<br>\njava<br>\n1.8之前HasMap和其它的map都是通过链地址法解决冲突，这种方法在最坏的情况下会使HashMap的性能降低到O(n)，为了解决这个问题，java<br>\n1.8中使用红黑树代替链表解决冲突，当链表中元素的数目达到一定值会将链表转化为红黑树，这样最坏情况下的性能也有O(logn)；</p>\n<p><strong>HashMap类的参数：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 序列化ID  </span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">serialVersionUID</span> <span class=\"operator\">=</span> <span class=\"number\">362498820763181265L</span>;  </span><br><span class=\"line\"><span class=\"comment\">// 默认的初始容量16，即桶的数量  </span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_INITIAL_CAPACITY</span> <span class=\"operator\">=</span> <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>;   </span><br><span class=\"line\"><span class=\"comment\">// 最大容量  </span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">MAXIMUM_CAPACITY</span> <span class=\"operator\">=</span> <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>;  </span><br><span class=\"line\"><span class=\"comment\">// 默认装载因子  </span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">float</span> <span class=\"variable\">DEFAULT_LOAD_FACTOR</span> <span class=\"operator\">=</span> <span class=\"number\">0.75f</span>;  </span><br><span class=\"line\"><span class=\"comment\">// 当桶的元素数量大于8将链表转换为红黑树  </span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">TREEIFY_THRESHOLD</span> <span class=\"operator\">=</span> <span class=\"number\">8</span>;  </span><br><span class=\"line\"><span class=\"comment\">// 当桶的元素数量小于6将树还原成链表  </span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">UNTREEIFY_THRESHOLD</span> <span class=\"operator\">=</span> <span class=\"number\">6</span>;  </span><br><span class=\"line\"><span class=\"comment\">// 最小树形化容量：当哈希表容量小于这个值时才允许树形化链表  </span></span><br><span class=\"line\"><span class=\"comment\">// 否则桶内元素太多就直接扩容了，为避免扩容和树形化的冲突不能小于4*TREEIFY_THRESHOLD  </span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">MIN_TREEIFY_CAPACITY</span> <span class=\"operator\">=</span> <span class=\"number\">64</span>;  </span><br></pre></td></tr></table></figure>\n<p>Node类是HashMap的一个静态内部类，其实现了Map接口的内部接口Entry，Node类以链表节点的形式定义了哈希表中的键值对：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Node</span>&lt;K,V&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">Map</span>.Entry&lt;K,V&gt; &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">int</span> hash;  <span class=\"comment\">//哈希值，不可变  </span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> K key;  <span class=\"comment\">//键，不可变  </span></span><br><span class=\"line\">    V value;  <span class=\"comment\">//值  </span></span><br><span class=\"line\">    Node&lt;K,V&gt; next;  <span class=\"comment\">//下一个节点  </span></span><br><span class=\"line\"></span><br><span class=\"line\">    Node(<span class=\"type\">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;  </span><br><span class=\"line\">        <span class=\"built_in\">this</span>.hash = hash;  </span><br><span class=\"line\">        <span class=\"built_in\">this</span>.key = key;  </span><br><span class=\"line\">        <span class=\"built_in\">this</span>.value = value;  </span><br><span class=\"line\">        <span class=\"built_in\">this</span>.next = next;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> K <span class=\"title function_\">getKey</span><span class=\"params\">()</span>        &#123; <span class=\"keyword\">return</span> key; &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title function_\">getValue</span><span class=\"params\">()</span>      &#123; <span class=\"keyword\">return</span> value; &#125;  </span><br><span class=\"line\">    <span class=\"comment\">// 重写toString方法  </span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123; <span class=\"keyword\">return</span> key + <span class=\"string\">&quot;=&quot;</span> + value; &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 重写Object的hashCode()方法，将key的hashCode与value的hashCode进行异或运算  </span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"title function_\">hashCode</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title function_\">setValue</span><span class=\"params\">(V newValue)</span> &#123;  </span><br><span class=\"line\">        <span class=\"type\">V</span> <span class=\"variable\">oldValue</span> <span class=\"operator\">=</span> value;  </span><br><span class=\"line\">        value = newValue;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldValue;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//重写Object的equals()方法，判断依据是键相等且值相等  </span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">equals</span><span class=\"params\">(Object o)</span> &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"built_in\">this</span>)  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o <span class=\"keyword\">instanceof</span> Map.Entry) &#123;  </span><br><span class=\"line\">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;  </span><br><span class=\"line\">                Objects.equals(value, e.getValue()))  </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>此外，HashMap中关键变量如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 存放Node节点的数组  </span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Node&lt;K,V&gt;[] table;  </span><br><span class=\"line\"><span class=\"comment\">// 存放Node节点的集合  </span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;  </span><br><span class=\"line\"><span class=\"comment\">// HashMap存放的数据个数  </span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"type\">int</span> size;  </span><br><span class=\"line\"><span class=\"comment\">// 记录HashMap的修改次数  </span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"type\">int</span> modCount;  </span><br><span class=\"line\"><span class=\"comment\">// 当HashMap大于threshold会进行resize  </span></span><br><span class=\"line\"><span class=\"type\">int</span> threshold;  </span><br><span class=\"line\"><span class=\"comment\">// HashMap的装填因子  </span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">float</span> loadFactor;  </span><br></pre></td></tr></table></figure>\n<p>由上面的代码可以看出HashMap包含一个Node数组table，每一个Node可以看作一个链表表头节点，table的每一个位置可以看作是一个桶(bucket)，桶中存放的是发生哈希冲突的节点组成的链表；</p>\n<p><img src=\"images/Java_HashMap/HashMap-table.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p><strong>HashMap的构造方法：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">HashMap</span><span class=\"params\">()</span> &#123;...&#125;  <span class=\"comment\">//默认容量16，装填因子0.75  </span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">HashMap</span><span class=\"params\">(<span class=\"type\">int</span> initialCapacity)</span> &#123;...&#125;  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">HashMap</span><span class=\"params\">(<span class=\"type\">int</span> initialCapacity, <span class=\"type\">float</span> loadFactor)</span> &#123;...&#125;  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">HashMap</span><span class=\"params\">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;...&#125;  <span class=\"comment\">//根据一个map构造HashMap  </span></span><br></pre></td></tr></table></figure>\n<p><strong>HashMap类的hash()方法：</strong><br>\nHashMap类的hash()方法用于计算key的哈希值，计算方式是将key的hashCode()值与右移16位的结果进行异或运算，简单来说就是将高位的值和低位的值进行结合，降低哈希冲突的概率；<br>\n1.7版本中的hash()方法的计算方式更复杂一点，并且还有计算哈希表索引的indexFor()方法，在1.8中hash()的计算简化，并且将indexFor()的计算放在了各个方法里；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"title function_\">hash</span><span class=\"params\">(Object key)</span> &#123;  </span><br><span class=\"line\">    <span class=\"type\">int</span> h;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"literal\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>根据hash()的结果计算索引是直接使用位运算<code>&amp;</code>实现的，相比于取模运算更快；</p>\n<blockquote>\n<p>如果length等于2的n次方，h%length =<br>\nh&amp;(length-1)，如当length=8，也就是1000，则length-1是0111，h&amp;(0111)相当于取h的后三位，也就是h%length；</p>\n</blockquote>\n<p><strong>HashMap类的put()方法：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> V <span class=\"title function_\">put</span><span class=\"params\">(K key, V value)</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"literal\">false</span>, <span class=\"literal\">true</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"keyword\">final</span> V <span class=\"title function_\">putVal</span><span class=\"params\">(<span class=\"type\">int</span> hash, K key, V value, <span class=\"type\">boolean</span> onlyIfAbsent, <span class=\"type\">boolean</span> evict)</span> &#123;  </span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab;   </span><br><span class=\"line\">    Node&lt;K,V&gt; p;   </span><br><span class=\"line\">    <span class=\"type\">int</span> n, i;  </span><br><span class=\"line\">    <span class=\"comment\">// 如果table为null或长度为0则创建一个table  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) == <span class=\"literal\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)  </span><br><span class=\"line\">        n = (tab = resize()).length;  </span><br><span class=\"line\">    <span class=\"comment\">// 计算索引的位置，如果该位置没有元素就创建node放入  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"literal\">null</span>)  </span><br><span class=\"line\">        tab[i] = newNode(hash, key, value, <span class=\"literal\">null</span>);  </span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;  <span class=\"comment\">// 否则说明该索引位置有元素  </span></span><br><span class=\"line\">        Node&lt;K,V&gt; e;   </span><br><span class=\"line\">        K k;  </span><br><span class=\"line\">        <span class=\"comment\">// 判断想要放入的节点是否已经存在  </span></span><br><span class=\"line\">        <span class=\"comment\">//节点的hash()相同并且key的值或地址相等就认为两个节点相等，直接更新value  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;  </span><br><span class=\"line\">            ((k = p.key) == key || (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k))))  </span><br><span class=\"line\">            e = p;  </span><br><span class=\"line\">        <span class=\"comment\">// 如果是红黑树就在树中插入节点  </span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)  </span><br><span class=\"line\">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"built_in\">this</span>, tab, hash, key, value);  </span><br><span class=\"line\">        <span class=\"comment\">// 否则的话就在链表中插入  </span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">binCount</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; ; ++binCount) &#123;  </span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"literal\">null</span>) &#123;  </span><br><span class=\"line\">                    p.next = newNode(hash, key, value, <span class=\"literal\">null</span>);  </span><br><span class=\"line\">                    <span class=\"comment\">// 如果链表长度超过阈值则转换成红黑树  </span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st  </span></span><br><span class=\"line\">                        treeifyBin(tab, hash);  </span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">                <span class=\"comment\">// 如果的插入节点key已存在则覆盖  </span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;  </span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k))))  </span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;  </span><br><span class=\"line\">                p = e;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"comment\">// key已存在则返回旧的value  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"literal\">null</span>) &#123; <span class=\"comment\">// existing mapping for key  </span></span><br><span class=\"line\">            <span class=\"type\">V</span> <span class=\"variable\">oldValue</span> <span class=\"operator\">=</span> e.value;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"literal\">null</span>)  </span><br><span class=\"line\">                e.value = value;  </span><br><span class=\"line\">            afterNodeAccess(e);  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"comment\">// 说明没有相同的key，插入一个key-value，结构变化+1  </span></span><br><span class=\"line\">    ++modCount;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++size &gt; threshold)  </span><br><span class=\"line\">        resize();  </span><br><span class=\"line\">    afterNodeInsertion(evict);  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>put()的过程如下图所示：</p>\n<p><img src=\"images/Java_HashMap/HashMap-put.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p><strong>HashMap类的get()方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> V <span class=\"title function_\">get</span><span class=\"params\">(Object key)</span> &#123;  </span><br><span class=\"line\">    Node&lt;K,V&gt; e;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> (e = getNode(hash(key), key)) == <span class=\"literal\">null</span> ? <span class=\"literal\">null</span> : e.value;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title function_\">getNode</span><span class=\"params\">(<span class=\"type\">int</span> hash, Object key)</span> &#123;  </span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class=\"type\">int</span> n; K k;  </span><br><span class=\"line\">    <span class=\"comment\">// 如果表不是null、长度不为0且要查找的位置不为空  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) != <span class=\"literal\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;  </span><br><span class=\"line\">        (first = tab[(n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"literal\">null</span>) &#123;  </span><br><span class=\"line\">        <span class=\"comment\">// 检查第一个节点是否是要找的  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first.hash == hash &amp;&amp; <span class=\"comment\">// always check first node  </span></span><br><span class=\"line\">            ((k = first.key) == key || (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k))))  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> first;  </span><br><span class=\"line\">        <span class=\"comment\">// 否则从第二个节点开始找  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e = first.next) != <span class=\"literal\">null</span>) &#123;  </span><br><span class=\"line\">            <span class=\"comment\">// 如果是红黑树则在树种查找  </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (first <span class=\"keyword\">instanceof</span> TreeNode)  </span><br><span class=\"line\">                <span class=\"keyword\">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);  </span><br><span class=\"line\">            <span class=\"comment\">// 否则在链表中查找  </span></span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;  </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;  </span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k))))  </span><br><span class=\"line\">                    <span class=\"keyword\">return</span> e;  </span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"literal\">null</span>);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p><strong>HashMap的扩容</strong><br>\nHashMap的初始大小为16，当包含的元素超过装载因子就进行扩容，每次扩容为原来的2倍，扩容之后元素的位置要么不变，要么是在原位置移动2次幂，如：当从16扩容到32，假设原来hash(key)是30，计算的索引是30&amp;(16-1)=14，扩容之后就是14+16=30；</p>\n<p><img src=\"images/Java_HashMap/HashMap-resize.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>因此扩容之后只需要判断原来的hash(key)对应2*oldCap-1高位的是否为1，如：31的最高位为16，对应30该位为1，因此需要修改key为新索引，否则位置不变；</p>\n","prev":{"title":"学习笔记：Java中的注解与反射(二)","link":"2020/07/09/blog/Java_annotation2"},"next":{"title":"学习笔记：Java并发、多线程","link":"2020/04/28/blog/Java_Multithreading"},"plink":"https://github.com/qfzack/2020/04/30/blog/Java_HashMap/","copyright":{"author":"Qingfeng Zhang","link":"<a href=\"https://github.com/qfzack/2020/04/30/blog/Java_HashMap/\" title=\"Java集合-初读HashMap源码\">https://github.com/qfzack/2020/04/30/blog/Java_HashMap/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"},"reading_time":"2004 words in 13 min"}