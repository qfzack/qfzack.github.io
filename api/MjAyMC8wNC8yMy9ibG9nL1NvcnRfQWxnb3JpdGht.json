{"title":"数据结构：排序算法总结","date":"2020-04-24T05:00:00.000Z","date_formatted":{"ll":"Apr 24, 2020","L":"04/24/2020","MM-DD":"04-24"},"author":"Qingfeng Zhang","link":"2020/04/23/blog/Sort_Algorithm","categories":["Algorithm"],"updated":"2025-04-13T10:59:37.513Z","content":"<h1 id=\"算法比较\">算法比较<a title=\"#算法比较\" href=\"#算法比较\"></a></h1>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th>排序算法</th>\n<th>时间复杂度(平均)</th>\n<th>时间复杂度(最坏)</th>\n<th>时间复杂度(最好)</th>\n<th>空间复杂度</th>\n<th>稳定性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>插入排序</td>\n<td>O(n^2)</td>\n<td>O(n^2)</td>\n<td>O(n)</td>\n<td>O(1)</td>\n<td>稳定</td>\n</tr>\n<tr>\n<td>希尔排序</td>\n<td>O(n^{1.3})</td>\n<td>O(n^2)</td>\n<td>O(n)</td>\n<td>O(1)</td>\n<td>不稳定</td>\n</tr>\n<tr>\n<td>选择排序</td>\n<td>O(n^2)</td>\n<td>O(n^2)</td>\n<td>O(n^2)</td>\n<td>O(1)</td>\n<td>不稳定</td>\n</tr>\n<tr>\n<td>堆排序</td>\n<td>O(nlog_2^n)</td>\n<td>O(nlog_2^n)</td>\n<td>O(nlog_2^n)</td>\n<td>O(1)</td>\n<td>不稳定</td>\n</tr>\n<tr>\n<td>冒泡排序</td>\n<td>O(n^2)</td>\n<td>O(n^2)</td>\n<td>O(n)</td>\n<td>O(1)</td>\n<td>稳定</td>\n</tr>\n<tr>\n<td>归并排序</td>\n<td>O(nlog_2^n)</td>\n<td>O(nlog_2^n)</td>\n<td>O(nlog_2^n)</td>\n<td>O(n)</td>\n<td>稳定</td>\n</tr>\n<tr>\n<td>快速排序</td>\n<td>O(nlog_2^n)</td>\n<td>O(n^2)</td>\n<td>O(nlog_2^n)</td>\n<td>O(nlog_2^n)</td>\n<td>不稳定</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>计数排序</td>\n<td>O(n+k)</td>\n<td>O(n+k)</td>\n<td>O(n+k)</td>\n<td>O(n+k)</td>\n<td>稳定</td>\n</tr>\n<tr>\n<td>桶排序</td>\n<td>O(n+k)</td>\n<td>O(n^2)</td>\n<td>O(n)</td>\n<td>O(n+k)</td>\n<td>稳定</td>\n</tr>\n<tr>\n<td>基数排序</td>\n<td>O(n*k)</td>\n<td>O(n*k)</td>\n<td>O(n*k)</td>\n<td>O(n+k)</td>\n<td>稳定</td>\n</tr>\n</tbody>\n</table></div></div><h1 id=\"算法实现\">算法实现<a title=\"#算法实现\" href=\"#算法实现\"></a></h1>\n<h2 id=\"插入排序\">插入排序<a title=\"#插入排序\" href=\"#插入排序\"></a></h2>\n<p>插入排序的基本思想是每一步将一个待排序的数据插入到前面已经排好序的有序序列中，直到插入完所有的元素；<br>\n<img src=\"images/Sort_Algorithm/insert.gif\" alt=\"\" loading=\"lazy\"></p>\n<ul>\n<li>算法描述</li>\n</ul>\n<p>1.从数组的第二个元素开始往前比较，如果比前面的数小就交换位置；<br>\n2.遍历将每个元素往前比较，直到数据全部排序完；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Insert</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;  </span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);  </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> sc.nextInt();  </span><br><span class=\"line\">        <span class=\"type\">int</span>[] nums = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n];  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;  </span><br><span class=\"line\">            nums[i] = sc.nextInt();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        InsertSort(nums);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">InsertSort</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;nums.length;i++)&#123;  </span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> i;  </span><br><span class=\"line\">            <span class=\"keyword\">while</span>(j&gt;<span class=\"number\">0</span> &amp;&amp; nums[j]&lt;nums[j-<span class=\"number\">1</span>])&#123;  </span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">tmp</span> <span class=\"operator\">=</span> nums[j];  </span><br><span class=\"line\">                nums[j] = nums[j-<span class=\"number\">1</span>];  </span><br><span class=\"line\">                nums[j-<span class=\"number\">1</span>] = tmp;  </span><br><span class=\"line\">                j--;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<h2 id=\"冒泡排序\">冒泡排序<a title=\"#冒泡排序\" href=\"#冒泡排序\"></a></h2>\n<p>冒泡排序直观的理解就是每次将较大的数下沉到数组后面，较小的数冒出到数组前面，每次可以将最大的数放在最后一个位置，则下一次冒泡就不考虑这个数，依次迭代直到所有的数都放在正确的位置；<br>\n<img src=\"images/Sort_Algorithm/bubble.gif\" alt=\"\" loading=\"lazy\"></p>\n<ul>\n<li>算法描述：</li>\n</ul>\n<p>1.比较第1,2个元素，如果前者更大，则交换；<br>\n2.比较第2,3个元素……遍历到最后完成一趟冒泡，此时最后一个元素是最大值；<br>\n3.第二趟冒泡，比较次数减一，将第二大的值放在倒数第二个位置；<br>\n4.依次执行，每次冒泡比较的次数减一……</p>\n<p><img src=\"images/Sort_Algorithm/bubble2.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Bubble</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;  </span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);  </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> sc.nextInt();  </span><br><span class=\"line\">        <span class=\"type\">int</span>[] nums = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n];  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;  </span><br><span class=\"line\">            nums[i] = sc.nextInt();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        bubbleSort(nums);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">bubbleSort</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;nums.length-<span class=\"number\">1</span>;i++) &#123;  </span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">sign</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;  <span class=\"comment\">//可以设置一个标志位表明数组是否已经有序  </span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; nums.length-i-<span class=\"number\">1</span>; j++) &#123;  </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nums[j] &gt; nums[j + <span class=\"number\">1</span>]) &#123;  </span><br><span class=\"line\">                    <span class=\"type\">int</span> <span class=\"variable\">tmp</span> <span class=\"operator\">=</span> nums[j];  </span><br><span class=\"line\">                    nums[j] = nums[j + <span class=\"number\">1</span>];  </span><br><span class=\"line\">                    nums[j + <span class=\"number\">1</span>] = tmp;  </span><br><span class=\"line\">                    sign = <span class=\"literal\">false</span>;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sign) <span class=\"keyword\">return</span> ;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"归并排序\">归并排序<a title=\"#归并排序\" href=\"#归并排序\"></a></h2>\n<p>归并排序(merge-sort)是利用归并思想实现的排序算法，采用分治策略，将问题分成一些小问题进行求解，然后将结果进行合并；</p>\n<p><img src=\"images/Sort_Algorithm/merge-sort.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>每次的合并都是合并两个有序数组：</p>\n<p><img src=\"images/Sort_Algorithm/merge.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>实现细节：</p>\n<ul>\n<li>使用DivideAndCombine方法进行递归，实现分治策略，每次将数组分两半；</li>\n<li>需要使用一个临时数组用于暂存两个子数组归并之后的有序结果，并且还要复制回原数组；</li>\n<li>每次都是对两个有序子数据进行归并，用两个指针指向数组最左端进行比较；</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;  </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Merge</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;  </span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);  </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> sc.nextInt();  </span><br><span class=\"line\">        <span class=\"type\">int</span>[] nums = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n];  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;  </span><br><span class=\"line\">            nums[i] = sc.nextInt();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        mergeSort(nums);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">mergeSort</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span>&#123;  </span><br><span class=\"line\">        <span class=\"type\">int</span>[] tmp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums.length];  </span><br><span class=\"line\">        DivideAndCombine(nums,tmp,<span class=\"number\">0</span>,nums.length-<span class=\"number\">1</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">DivideAndCombine</span><span class=\"params\">(<span class=\"type\">int</span>[] nums,<span class=\"type\">int</span>[] tmp,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l&gt;=r) <span class=\"keyword\">return</span> ;  </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> (r-l)/<span class=\"number\">2</span>+l;  </span><br><span class=\"line\">        DivideAndCombine(nums, tmp, l, mid);  </span><br><span class=\"line\">        DivideAndCombine(nums, tmp, mid + <span class=\"number\">1</span>, r);  </span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">//进行有序数组的合并  </span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> l, y = mid + <span class=\"number\">1</span>;  <span class=\"comment\">//x,y分别指向两个有序数组的左边界  </span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> l;  <span class=\"comment\">//cur指向临时数组  </span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(x&lt;=mid &amp;&amp; y&lt;=r)&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[x]&lt;nums[y])&#123;  <span class=\"comment\">//每次将两个数组的最小值赋给tmp[cur]  </span></span><br><span class=\"line\">                tmp[cur++] = nums[x++];  </span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;  </span><br><span class=\"line\">                tmp[cur++] = nums[y++];  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(x&lt;=mid) tmp[cur++] = nums[x++];  <span class=\"comment\">//右数组先归并完  </span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(y&lt;=r) tmp[cur++] = nums[y++];  <span class=\"comment\">//左数组先归并完  </span></span><br><span class=\"line\">        <span class=\"comment\">//将两个子数组的归并排序结果复制到原数组  </span></span><br><span class=\"line\">        cur = l;  </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur&lt;=r) &#123;  </span><br><span class=\"line\">            nums[cur] = tmp[cur++];  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>LeetCode的<code>剑指offer51.数组中的逆序对</code>和<code>NO.315 计算右侧小于当前元素的个数</code>就是利用归并排序求数组中逆序对的数量；</p>\n</blockquote>\n<h2 id=\"快速排序\">快速排序<a title=\"#快速排序\" href=\"#快速排序\"></a></h2>\n<p>快速排序的思想是通过一趟排序将待排的记录分隔为两部分，其中一部分的关键字均比另一部分的小，再对两部分分别进行快速排序，最终达到整个序列有序；<br>\n每次将序列中的最左元素作为基准数，使得基准数大于左边的所有关键字，且小于右边的所有关键字，下图是基准数为23的一趟快速排序：</p>\n<p><img src=\"images/Sort_Algorithm/quicksort.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>最终基准数23可以将原数组分为两个序列，然后分别对两个序列进行快速排序；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;  </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;  </span><br><span class=\"line\">        <span class=\"type\">int</span>[] nums = &#123;<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"number\">6</span>,<span class=\"number\">8</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">5</span>,<span class=\"number\">9</span>&#125;;  </span><br><span class=\"line\">        sort(nums);  </span><br><span class=\"line\">        System.out.println(Arrays.toString(nums));  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sort</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span>&#123;  </span><br><span class=\"line\">        quickSort(nums,<span class=\"number\">0</span>,nums.length-<span class=\"number\">1</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">quickSort</span><span class=\"params\">(<span class=\"type\">int</span>[] nums,<span class=\"type\">int</span> left,<span class=\"type\">int</span> right)</span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(left&gt;right) <span class=\"keyword\">return</span> ;  </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">base</span> <span class=\"operator\">=</span> nums[left];  <span class=\"comment\">//以左边元素为基准数  </span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">l</span> <span class=\"operator\">=</span> left, r = right;  </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l&lt;r)&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">while</span>(l&lt;r &amp;&amp; base&lt;=nums[r]) r--;  <span class=\"comment\">//从右往左找到小于base的数  </span></span><br><span class=\"line\">            nums[l] = nums[r];  <span class=\"comment\">//放到左边  </span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(l&lt;r &amp;&amp; base&gt;=nums[l]) l++;  <span class=\"comment\">//从左往右找到大于base的数  </span></span><br><span class=\"line\">            nums[r] = nums[l];  <span class=\"comment\">//放到右边  </span></span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        nums[l] = base;  <span class=\"comment\">//放置base，左边均小于base，右边均大于base  </span></span><br><span class=\"line\">        quickSort(nums,left,l-<span class=\"number\">1</span>);  <span class=\"comment\">//对base左边进行快排  </span></span><br><span class=\"line\">        quickSort(nums,l+<span class=\"number\">1</span>,right);  <span class=\"comment\">//对base右边进行快排  </span></span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>LeetCode的<code>面试题40. 最小的k个数</code>用到了快排的partition思想；</p>\n</blockquote>\n","prev":{"title":"学习笔记：Java并发、多线程","link":"2020/04/27/blog/Java_Multithreading"},"next":{"title":"学习笔记：Java虚拟机JVM","link":"2020/04/04/blog/Java_JVM"},"plink":"https://qfzack.github.io/2020/04/23/blog/Sort_Algorithm/","toc":[{"id":"算法比较","title":"算法比较","index":"1"},{"id":"算法实现","title":"算法实现","index":"2","children":[{"id":"插入排序","title":"插入排序","index":"2.1"},{"id":"冒泡排序","title":"冒泡排序","index":"2.2"},{"id":"归并排序","title":"归并排序","index":"2.3"},{"id":"快速排序","title":"快速排序","index":"2.4"}]}],"reading_time":"1618 words in 11 min"}