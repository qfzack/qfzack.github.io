{"title":"最小生成树算法","date":"2020-08-15T05:00:00.000Z","date_formatted":{"ll":"Aug 15, 2020","L":"08/15/2020","MM-DD":"08-15"},"author":"Qingfeng Zhang","link":"2020/08/14/blog/minimumSpanningTree","categories":["Data Structure"],"updated":"2025-05-07T15:55:24.289Z","content":"<p>最小生成树问题一般定义为：一个有n个节点的连通图的生成树是原图的极小连通子图，且包含原图中的所有n个节点，并且保持图连通的边的权值和最小；<br>\n构建最小生成树的算法有<strong>prim算法</strong> 和<strong>kruskal算法</strong> ；</p>\n<p>定义一个无向连通图如下：</p>\n<p><img src=\"images/MinimumSpanningTree/prim.jpg\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<blockquote>\n<p>图的表示方法有邻接矩阵和邻接表；</p>\n</blockquote>\n<h1 id=\"prim算法\">prim算法<a title=\"#prim算法\" href=\"#prim算法\"></a></h1>\n<ul>\n<li>假设V是所有节点的集合，先选取一个初始节点加入集合U</li>\n<li>选择以这个节点为起点的最小权值边，将终点加入U</li>\n<li>每次选择起点在U中，终点在V-U中且权值最小的边</li>\n<li>直到所有节点连通</li>\n</ul>\n<p>选择使用邻接矩阵构造最小生成树的prim算法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">prim</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;  </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;  <span class=\"comment\">//最小生成树的权值之和  </span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">M</span> <span class=\"operator\">=</span> Integer.MAX_VALUE;  </span><br><span class=\"line\">        <span class=\"comment\">//1.构造图的邻接矩阵（问题一般会给出每条边的信息，这里假设是一个无向图）  </span></span><br><span class=\"line\">        <span class=\"type\">int</span>[][] weight = &#123;&#123; <span class=\"number\">0</span>,<span class=\"number\">10</span>, M, M, M,<span class=\"number\">11</span>, M, M, M&#125;,  </span><br><span class=\"line\">                            &#123;<span class=\"number\">10</span>, <span class=\"number\">0</span>,<span class=\"number\">18</span>, M, M, M,<span class=\"number\">16</span>, M,<span class=\"number\">12</span>&#125;,  </span><br><span class=\"line\">                            &#123; M,<span class=\"number\">18</span>, <span class=\"number\">0</span>,<span class=\"number\">22</span>, M, M, M, M, <span class=\"number\">8</span>&#125;,  </span><br><span class=\"line\">                            &#123; M, M,<span class=\"number\">22</span>, <span class=\"number\">0</span>,<span class=\"number\">26</span>, M, M,<span class=\"number\">16</span>,<span class=\"number\">21</span>&#125;,  </span><br><span class=\"line\">                            &#123; M, M, M,<span class=\"number\">20</span>, <span class=\"number\">0</span>,<span class=\"number\">26</span>, M, <span class=\"number\">7</span>, M&#125;,  </span><br><span class=\"line\">                            &#123;<span class=\"number\">11</span>, M, M, M,<span class=\"number\">26</span>, <span class=\"number\">0</span>,<span class=\"number\">17</span>, M, M&#125;,  </span><br><span class=\"line\">                            &#123; M,<span class=\"number\">16</span>, M, M, M,<span class=\"number\">17</span>, <span class=\"number\">0</span>,<span class=\"number\">19</span>, M&#125;,  </span><br><span class=\"line\">                            &#123; M, M, M,<span class=\"number\">16</span>, <span class=\"number\">7</span>, M,<span class=\"number\">19</span>, <span class=\"number\">0</span>, M&#125;,  </span><br><span class=\"line\">                            &#123; M,<span class=\"number\">12</span>, <span class=\"number\">8</span>,<span class=\"number\">21</span>, M, M, M, M, <span class=\"number\">0</span>&#125;  </span><br><span class=\"line\">                            &#125;;  </span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">//2.选择一个初始节点，并初始化数组edge  </span></span><br><span class=\"line\">        <span class=\"comment\">//  edge中存放的是当前可以选择的最小权值的边  </span></span><br><span class=\"line\">        <span class=\"type\">int</span>[] edge = weight[<span class=\"number\">0</span>];  </span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">//3.每次添加一条最小权值的边  </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;edge.length;i++)&#123;  </span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">//4.每次从edge中选出最小权值的边  </span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>, minv = M;  <span class=\"comment\">//i-k这条边的权值最小，且最小权值为minv  </span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;edge.length;j++)&#123;  </span><br><span class=\"line\">                <span class=\"keyword\">if</span>(edge[j]&gt;<span class=\"number\">0</span> &amp;&amp; edge[j]!=M)&#123;  <span class=\"comment\">//如果节点j与i相连  </span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(edge[j]&lt;minv)&#123;  <span class=\"comment\">//并且i-j的权值小于minv  </span></span><br><span class=\"line\">                        k = j;  <span class=\"comment\">//更新k为节点j  </span></span><br><span class=\"line\">                        minv = edge[j];  <span class=\"comment\">//更新最小权值  </span></span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">//5.判断最小权值边是否存在  </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(k==-<span class=\"number\">1</span>) <span class=\"keyword\">break</span>;  </span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">//6.找到了节点k使得i-k这条边是当前所选的  </span></span><br><span class=\"line\">            sum += edge[k];  </span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">//7.更新当前可选的最小权值边edge  </span></span><br><span class=\"line\">            <span class=\"comment\">//  因为加入了节点k，所以可选的边也增加了weight[k]  </span></span><br><span class=\"line\">            <span class=\"comment\">//  对于weight[k]和edge，取每个位置最小值赋edge  </span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;edge.length;j++)&#123;  </span><br><span class=\"line\">                edge[j] = Math.min(weight[k][j],edge[j]);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        System.out.println(sum);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>构造的过程如下图所示：</p>\n<ul>\n<li>绿色的边是数组edge中存放的可用的边；</li>\n<li>红色的边是选取的最小权值的边；</li>\n</ul>\n<p><img src=\"images/MinimumSpanningTree/prim2.webp\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<h1 id=\"kruskal算法\">kruskal算法<a title=\"#kruskal算法\" href=\"#kruskal算法\"></a></h1>\n<ul>\n<li>将所有边的权值从小到大排序</li>\n<li>每次选取权值最小的边，如果此边构成回路则无效，否则就是有效边</li>\n<li>遍历完所有边即得到最小生成树</li>\n</ul>\n<p>选择使用邻接表构造最小生成树的kruskal算法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;  </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">kruskal</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;  </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;  <span class=\"comment\">//最小生成树的权值之和  </span></span><br><span class=\"line\">        <span class=\"type\">int</span>[][] edges = &#123;&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">10</span>&#125;,  </span><br><span class=\"line\">                            &#123;<span class=\"number\">0</span>,<span class=\"number\">5</span>,<span class=\"number\">11</span>&#125;,  </span><br><span class=\"line\">                            &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">18</span>&#125;,  </span><br><span class=\"line\">                            &#123;<span class=\"number\">1</span>,<span class=\"number\">6</span>,<span class=\"number\">16</span>&#125;,  </span><br><span class=\"line\">                            &#123;<span class=\"number\">1</span>,<span class=\"number\">8</span>,<span class=\"number\">12</span>&#125;,  </span><br><span class=\"line\">                            &#123;<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">22</span>&#125;,  </span><br><span class=\"line\">                            &#123;<span class=\"number\">2</span>,<span class=\"number\">8</span>,<span class=\"number\">8</span>&#125;,  </span><br><span class=\"line\">                            &#123;<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">20</span>&#125;,  </span><br><span class=\"line\">                            &#123;<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">24</span>&#125;,  </span><br><span class=\"line\">                            &#123;<span class=\"number\">3</span>,<span class=\"number\">7</span>,<span class=\"number\">16</span>&#125;,  </span><br><span class=\"line\">                            &#123;<span class=\"number\">3</span>,<span class=\"number\">8</span>,<span class=\"number\">21</span>&#125;,  </span><br><span class=\"line\">                            &#123;<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">26</span>&#125;,  </span><br><span class=\"line\">                            &#123;<span class=\"number\">4</span>,<span class=\"number\">7</span>,<span class=\"number\">7</span>&#125;,  </span><br><span class=\"line\">                            &#123;<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">17</span>&#125;,  </span><br><span class=\"line\">                            &#123;<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">19</span>&#125;  </span><br><span class=\"line\">                        &#125;;  </span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">//1.将所有的边按照权值从小到大排序  </span></span><br><span class=\"line\">        Arrays.sort(edges,(o1,o2)-&gt;o1[<span class=\"number\">2</span>]-o2[<span class=\"number\">2</span>]);  </span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">//2.数组arr[i]表示存在边i-end[i]  </span></span><br><span class=\"line\">        <span class=\"type\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">9</span>];  <span class=\"comment\">//9个节点  </span></span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">//3.遍历每一条边  </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span>[] edge: edges)&#123;  </span><br><span class=\"line\">            <span class=\"comment\">//4.找到这条边起点和终点的代表节点  </span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> find(arr,edge[<span class=\"number\">0</span>]);  </span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">end</span> <span class=\"operator\">=</span> find(arr,edge[<span class=\"number\">1</span>]);  </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(start!=end)&#123;  </span><br><span class=\"line\">                <span class=\"comment\">//5.如果两个节点不在同一个连通分量中  </span></span><br><span class=\"line\">                arr[start] = end;  </span><br><span class=\"line\">                sum += edge[<span class=\"number\">2</span>];  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        System.out.println(sum);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//找到x的代表节点  </span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">find</span><span class=\"params\">(<span class=\"type\">int</span>[] arr, <span class=\"type\">int</span> x)</span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(arr[x]&gt;<span class=\"number\">0</span>)&#123;  </span><br><span class=\"line\">            x = arr[x];  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意，在遍历到边0-5的时候，find(0)=1,find(5)=5，这时候出于<strong>代码实现的考虑</strong><br>\n在arr中记录1-5，而实际的图中并没有1-5这条边，并且此时生成树添加的边也是0-5；<br>\n代表节点的思想有点类似并查集；</p>\n</blockquote>\n<p>构造的过程如下图所示：</p>\n<ul>\n<li>绿色的边是找到的权值最小但是是同一个连通分量的边；</li>\n<li>红色的边是选取的最小权值的边；</li>\n</ul>\n<p><img src=\"images/MinimumSpanningTree/prim2.webp\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<h1 id=\"算法分析\">算法分析<a title=\"#算法分析\" href=\"#算法分析\"></a></h1>\n<ul>\n<li>prim算法的时间复杂度是 O(n^2) ，n是节点的个数，与边的数量无关，适合求边稠密图的最小生成树；</li>\n<li>kruskal算法的时间复杂度是 O(eloge) ，e是边的个数，与节点的数量无关，适合求稀疏图的最小生成树；~</li>\n</ul>\n","prev":{"title":"NO.84&85 柱状图中的最大矩形问题","link":"2020/09/28/blog/LeetCode-84&85"},"next":{"title":"学习笔记：Java中的注解与反射(二)","link":"2020/07/08/blog/Java_annotation2"},"plink":"https://qfzack.github.io/2020/08/14/blog/minimumSpanningTree/","toc":[{"id":"prim算法","title":"prim算法","index":"1"},{"id":"kruskal算法","title":"kruskal算法","index":"2"},{"id":"算法分析","title":"算法分析","index":"3"}],"reading_time":"1263 words in 8 min"}