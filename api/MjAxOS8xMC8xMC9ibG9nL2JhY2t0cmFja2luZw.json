{"title":"Python-回溯算法","date":"2019-10-11T05:00:00.000Z","date_formatted":{"ll":"Oct 11, 2019","L":"10/11/2019","MM-DD":"10-11"},"author":"Qingfeng Zhang","link":"2019/10/10/blog/backtracking","categories":["Algorithm"],"updated":"2025-09-14T15:49:00.952Z","content":"<h2 id=\"一、算法概述\">一、算法概述<a title=\"#一、算法概述\" href=\"#一、算法概述\"></a></h2>\n<p>回溯法的思想就是把问题的解空间转化为图或者树的结构表示，然后使用深度优先搜索策略进行遍历，在遍历的过程中记录和寻找所有可行解或者最优解：</p>\n<ul>\n<li>其思想类同于<strong>图的深度优先搜索</strong>、<strong>二叉树的后序遍历</strong></li>\n<li>回溯法的实现：递归和递推</li>\n<li>经典问题：八皇后问题和迷宫问题</li>\n</ul>\n<h2 id=\"二、算法实例\">二、算法实例<a title=\"#二、算法实例\" href=\"#二、算法实例\"></a></h2>\n<h3 id=\"no.22-括号生成\">NO.22 括号生成<a title=\"#no.22-括号生成\" href=\"#no.22-括号生成\"></a></h3>\n<ul>\n<li>\n<p>问题描述<br>\n给出一个数n表示可以使用的括号的对数，返回n对括号可以组成的所有有效括号的组合；</p>\n</li>\n<li>\n<p>思路分析<br>\n最简单的想法就是，对于每一种组合，先从第一个括号开始放，直到放完2n个括号，期间要保证括号序列是合法的，也就是说，每放一个括号的前后都要保证右括号数量不能多于左括号的数量；<br>\n对于当前的合法序列，如果左右括号数量相等，那么下一步就只能放左括号；如果左括号的数量多于右括号，那么下一步就有两种情况：放左括号和放右括号；<br>\n第一步只能放一个左括号，对于n=3的情况如下图所示：</p>\n</li>\n</ul>\n<p><img src=\"images/backtracking/bt1.jpg\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>在两种情况下一个节点没有两个分支：左括号数量等于n、左右括号数量相等</p>\n<ul>\n<li>求解代码</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:  </span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">generateParenthesis</span>(<span class=\"params\">self, n: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"type\">List</span>[<span class=\"built_in\">str</span>]:  </span><br><span class=\"line\">        ans = []  <span class=\"comment\">#存放每种括号组合的列表  </span></span><br><span class=\"line\">        <span class=\"keyword\">def</span> <span class=\"title function_\">backtrack</span>(<span class=\"params\">s = <span class=\"string\">&#x27;&#x27;</span>, left = <span class=\"number\">0</span>, right = <span class=\"number\">0</span></span>):  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(s) == n*<span class=\"number\">2</span>:  </span><br><span class=\"line\">                ans.append(s)  <span class=\"comment\">#当括号序列的长度为2n时，该序列就是一种组合  </span></span><br><span class=\"line\">                <span class=\"keyword\">return</span>   <span class=\"comment\">#不返回任何值，进代表函数运行结束  </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> left &lt; n:  <span class=\"comment\">#表示还有左括号可以用  </span></span><br><span class=\"line\">                backtrack(s+<span class=\"string\">&#x27;(&#x27;</span>, left+<span class=\"number\">1</span>, right)  <span class=\"comment\">#left表示使用了左括号的个数  </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> right &lt; left:  <span class=\"comment\">#表示此时可以使用右括号  </span></span><br><span class=\"line\">                backtrack(s+<span class=\"string\">&#x27;)&#x27;</span>, left, right+<span class=\"number\">1</span>)  <span class=\"comment\">#right表示使用了右括号的个数  </span></span><br><span class=\"line\">        backtrack()  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans  </span><br></pre></td></tr></table></figure>\n<p>代码的运行过程如下：</p>\n<p><img src=\"images/backtracking/bt2.jpg\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>backtrack函数由三个if语句组成，后两个if表示能否在当前的序列中加上左括号或右括号；<br>\n代码的运行过程与第一张图的<strong>树的后序遍历</strong><br>\n过程相似，先执行上图的函数1，函数内调用自身，执行函数2，函数而内调用自身，执行函数3和函数4.但是函数4是等函数3执行完（深度遍历结束进行回溯）再执行，函数3内的函数5和函数6同理，这个过程也可以看做<strong>图的深度优先遍历</strong>。</p>\n<h3 id=\"no.39-组合总数\">NO.39 组合总数<a title=\"#no.39-组合总数\" href=\"#no.39-组合总数\"></a></h3>\n<ul>\n<li>\n<p>问题描述<br>\n给出一个没有重复元素的数组candidates，一个目标数target，找出canditates中任意个元素的组合，该组合的元素和为target，元素可以重复使用</p>\n</li>\n<li>\n<p>思路分析<br>\n如果使用传统的方法一层一层的循环去找非常的耗费时间，因此使用回溯法，假设candidates的元素个数为n，则此问题的解空间就是一个n叉树，对此n叉树进行后序遍历</p>\n</li>\n<li>\n<p>求解代码</p>\n</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:  </span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">combinationSum</span>(<span class=\"params\">self, candidates: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>], target: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"type\">List</span>[<span class=\"type\">List</span>[<span class=\"built_in\">int</span>]]:  </span><br><span class=\"line\">        ans = []  </span><br><span class=\"line\">        n = <span class=\"built_in\">len</span>(candidates)  </span><br><span class=\"line\">        candidates.sort()  <span class=\"comment\">#排序是为了大于target之后不用再遍历下去  </span></span><br><span class=\"line\">        <span class=\"keyword\">def</span> <span class=\"title function_\">trackback</span>(<span class=\"params\">i, tmp_sum, tmp</span>):  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> tmp_sum &gt; target <span class=\"keyword\">or</span> i == n:  <span class=\"comment\">#如果总和大于target或者遍历canditates结束  </span></span><br><span class=\"line\">                <span class=\"keyword\">return</span>   <span class=\"comment\">#仅仅起到结束函数的作用  </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> tmp_sum == target:  </span><br><span class=\"line\">                ans.append(tmp)  </span><br><span class=\"line\">                <span class=\"keyword\">return</span>   </span><br><span class=\"line\">            trackback(i, tmp_sum+candidates[i], tmp+[candidates[i]])  <span class=\"comment\">#用于深度遍历  </span></span><br><span class=\"line\">            trackback(i+<span class=\"number\">1</span>, tmp_sum, tmp)  <span class=\"comment\">#用于回溯  </span></span><br><span class=\"line\">        trackback(<span class=\"number\">0</span>,<span class=\"number\">0</span>,[])  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans  </span><br></pre></td></tr></table></figure>\n<p>代码的运行过程如下：</p>\n<p><img src=\"images/backtracking/bt3.jpg\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>当一个分支满足终止条件（总和大于target或者遍历candidates结束）时，将其结束（return）；总和等于target时，将组合存放在ans中；<br>\n每一个节点都可以进行分支（没有条件），函数的参数中，i表示candidates中的下标，tmp_sum表示当前找到的序列的元素和，tmp表示当前找到的序列，最终符合要求的序列由tmp得到，这些参数都是由函数的参数表示</p>\n<h3 id=\"no.40-组合总数ii\">NO.40 组合总数II<a title=\"#no.40-组合总数ii\" href=\"#no.40-组合总数ii\"></a></h3>\n<ul>\n<li>\n<p>问题描述<br>\n与39题非常相似，区别在于candidates中的元素在每个组合中不能重复使用</p>\n</li>\n<li>\n<p>思路分析<br>\n依旧是根据问题的解空间进行求解，对于当前的结点有两种选择，一种选择是保留当前结点的值，另种是不保留，这两种选择各对应一种递归（感觉递归的写法大同小异，需要思考的是每次递归的退出和符合的判断条件），递归函数有两个参数：candidates的坐标和组合的列表，因此，当组合列表值的和等于target时将其加入ans并停止当前函数的递归，或者坐标超出范围或是组合列表的和大于target也停止函数的递归</p>\n</li>\n<li>\n<p>求解代码</p>\n</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:  </span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">combinationSum2</span>(<span class=\"params\">self, candidates: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>], target: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"type\">List</span>[<span class=\"type\">List</span>[<span class=\"built_in\">int</span>]]:  </span><br><span class=\"line\">        ans = []  </span><br><span class=\"line\">        n = <span class=\"built_in\">len</span>(candidates)  </span><br><span class=\"line\">        candidates.sort()  </span><br><span class=\"line\">        <span class=\"keyword\">def</span> <span class=\"title function_\">trackback</span>(<span class=\"params\">i,l</span>):  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"built_in\">sum</span>(l)==target:  </span><br><span class=\"line\">                <span class=\"keyword\">if</span> l <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> ans:  </span><br><span class=\"line\">                    ans.append(l)  </span><br><span class=\"line\">                <span class=\"keyword\">return</span>   </span><br><span class=\"line\">            <span class=\"keyword\">if</span> i&gt;n-<span class=\"number\">1</span> <span class=\"keyword\">or</span> <span class=\"built_in\">sum</span>(l)&gt;target:  </span><br><span class=\"line\">                <span class=\"keyword\">return</span>   </span><br><span class=\"line\">            trackback(i+<span class=\"number\">1</span>,l+[candidates[i]])  </span><br><span class=\"line\">            trackback(i+<span class=\"number\">1</span>,l)  </span><br><span class=\"line\">        trackback(<span class=\"number\">0</span>,[])  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans  </span><br></pre></td></tr></table></figure>\n<h3 id=\"no.77-列表的组合\">NO.77 列表的组合<a title=\"#no.77-列表的组合\" href=\"#no.77-列表的组合\"></a></h3>\n<ul>\n<li>\n<p>问题描述<br>\n给定一个整数n，对应一个从1到n整数列表L，再给定一个组合长度k，从L中选出k个不同的元素进行组合（组合的有序结果不能相同），返回所有的组合结果</p>\n</li>\n<li>\n<p>思路分析<br>\n依然是简单的回溯问题，问题的解空间可以看成一棵树，按照之前的”套路”，定义一个用于递归的函数，其参数一个是下标，一个是需要的组合，这个问题固定了树的深度为k+1，即每个组合的长度为k；<br>\n为了防止每种组合的有序结果不重复，可以对于当前的结点L[i]，其子节点从L[i+1]开始往后找；<br>\n问题的解空间如下图所示：</p>\n</li>\n</ul>\n<p><img src=\"images/backtracking/bt4.jpg\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<ul>\n<li>求解代码</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:  </span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">combine</span>(<span class=\"params\">self, n: <span class=\"built_in\">int</span>, k: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"type\">List</span>[<span class=\"type\">List</span>[<span class=\"built_in\">int</span>]]:  </span><br><span class=\"line\">        L = <span class=\"built_in\">list</span>(<span class=\"built_in\">range</span>(<span class=\"number\">1</span>,n+<span class=\"number\">1</span>))  </span><br><span class=\"line\">        ans = []  </span><br><span class=\"line\">        <span class=\"keyword\">def</span> <span class=\"title function_\">backtrack</span>(<span class=\"params\">i, l</span>):  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(l) == k <span class=\"keyword\">and</span> l <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> ans:  </span><br><span class=\"line\">                ans.append(l)  </span><br><span class=\"line\">                <span class=\"keyword\">return</span>   </span><br><span class=\"line\">            <span class=\"keyword\">if</span> i == n:  </span><br><span class=\"line\">                <span class=\"keyword\">return</span>   </span><br><span class=\"line\">            backtrack(i+<span class=\"number\">1</span>, l+[L[i]])  </span><br><span class=\"line\">            backtrack(i+<span class=\"number\">1</span>, l)  </span><br><span class=\"line\">        backtrack(<span class=\"number\">0</span>, [])  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans  </span><br></pre></td></tr></table></figure>\n<h3 id=\"no.78-列表的子集\">NO.78 列表的子集<a title=\"#no.78-列表的子集\" href=\"#no.78-列表的子集\"></a></h3>\n<ul>\n<li>\n<p>问题描述<br>\n给定一组不含重复元素数的列表，返回该列表所有可能的子集</p>\n</li>\n<li>\n<p>思路分析<br>\n依然是使用回溯法进行求解，问题的解空间可以用一颗二叉树表示，对于当前的结点有两个分支，一是加上下一个值作为列表，二是加上一个空列表（即不变）；<br>\n函数的参数只有两个：列表的下标i和所需的子集序列l；<br>\n问题的解空间如下图所示：</p>\n</li>\n</ul>\n<p><img src=\"images/backtracking/bt5.jpg\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<ul>\n<li>求解代码</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:  </span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">subsets</span>(<span class=\"params\">self, nums: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>]</span>) -&gt; <span class=\"type\">List</span>[<span class=\"type\">List</span>[<span class=\"built_in\">int</span>]]:  </span><br><span class=\"line\">        ans = []  </span><br><span class=\"line\">        <span class=\"keyword\">def</span> <span class=\"title function_\">backtrack</span>(<span class=\"params\">i, l</span>):  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> l <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> ans:  </span><br><span class=\"line\">                ans.append(l)  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> i == <span class=\"built_in\">len</span>(nums):  </span><br><span class=\"line\">                <span class=\"keyword\">return</span>   </span><br><span class=\"line\">            backtrack(i+<span class=\"number\">1</span>, l+[nums[i]])  </span><br><span class=\"line\">            backtrack(i+<span class=\"number\">1</span>, l)  </span><br><span class=\"line\">        backtrack(<span class=\"number\">0</span>, [])  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans  </span><br></pre></td></tr></table></figure>\n<h3 id=\"n0.90-子集ii\">N0.90 子集II<a title=\"#n0.90-子集ii\" href=\"#n0.90-子集ii\"></a></h3>\n<ul>\n<li>\n<p>问题描述<br>\n给定一个整数数组nums，其中可能含有重复元素，要得到该列表的所有可能的子集（不能重复）</p>\n</li>\n<li>\n<p>思路分析<br>\n又是一个非常典型的使用回溯法求解的问题，数组的子集中会包含空列表和自身，因此在解空间中，对于树的每一个节点有两个分支，一是往当前的列表l中加入nums的第i个元素，二是不对l添加元素，因此，递归的终止条件就是遍历nums结束<br>\n为了防止子集中因为顺序不同导致重复的情况，如[1,1,2]和[1,2,1]，先对nums进行排序，对于终止的每一个l，如果不在ans中，就将其添加到ans中<br>\n以[1,2,2]为例，解空间的树结构为：</p>\n</li>\n</ul>\n<p><img src=\"images/backtracking/bt6.jpg\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<ul>\n<li>求解代码</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:  </span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">subsetsWithDup</span>(<span class=\"params\">self, nums: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>]</span>) -&gt; <span class=\"type\">List</span>[<span class=\"type\">List</span>[<span class=\"built_in\">int</span>]]:  </span><br><span class=\"line\">        ans = []  </span><br><span class=\"line\">        nums.sort()  </span><br><span class=\"line\">        <span class=\"keyword\">def</span> <span class=\"title function_\">trackback</span>(<span class=\"params\">i,l</span>):  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> i&gt;<span class=\"built_in\">len</span>(nums)-<span class=\"number\">1</span>:  </span><br><span class=\"line\">                <span class=\"keyword\">if</span> l <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> ans:  </span><br><span class=\"line\">                    ans.append(l)  </span><br><span class=\"line\">                <span class=\"keyword\">return</span>   </span><br><span class=\"line\">            trackback(i+<span class=\"number\">1</span>,l)  </span><br><span class=\"line\">            trackback(i+<span class=\"number\">1</span>,l+[nums[i]])  </span><br><span class=\"line\">        trackback(<span class=\"number\">0</span>,[])  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans  </span><br></pre></td></tr></table></figure>\n<h3 id=\"no.131-分割回文串\">NO.131 分割回文串<a title=\"#no.131-分割回文串\" href=\"#no.131-分割回文串\"></a></h3>\n<ul>\n<li>\n<p>问题描述<br>\n给定一个字符串s，将其分割为多个字符串，要求每个分割后的每个字符串都是回文串，满足要求的一种分割作为一种组合，返回所有可能的组合</p>\n</li>\n<li>\n<p>思路分析<br>\n这道题依然是使用回溯法，但是这道题的解空间不想之前的题那样直观，如果用一棵树来表示，那么每一种组合就是树的一层节点的组合；<br>\n递归的结束条件依然是遍历s结束，递归函数的参数为传入的字符串s和当前的回文串的列表L，这两个参数的元素的和就是s；<br>\n函数内先判断是否满足退出条件，如果满足的话，L就是s的回文串分割组合，将其加入ans；<br>\n再对传入的字符串进行遍历，如果前i个元素组成回文串，就把剩余子串和前i个元素加入列表传入函数进行递归；</p>\n</li>\n<li>\n<p>求解代码</p>\n</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:  </span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">partition</span>(<span class=\"params\">self, s: <span class=\"built_in\">str</span></span>) -&gt; <span class=\"type\">List</span>[<span class=\"type\">List</span>[<span class=\"built_in\">str</span>]]:  </span><br><span class=\"line\">        ans = []  </span><br><span class=\"line\">        <span class=\"keyword\">def</span> <span class=\"title function_\">trackback</span>(<span class=\"params\">s, L</span>):  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> s:  </span><br><span class=\"line\">                ans.append(L)  </span><br><span class=\"line\">                <span class=\"keyword\">return</span>   </span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>,<span class=\"built_in\">len</span>(s)+<span class=\"number\">1</span>):  </span><br><span class=\"line\">                <span class=\"keyword\">if</span> s[:i] == s[:i][::-<span class=\"number\">1</span>]:  <span class=\"comment\">#判断是否是回文串  </span></span><br><span class=\"line\">                    trackback(s[i:], L+[s[:i]])  </span><br><span class=\"line\">        trackback(s, [])  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans  </span><br></pre></td></tr></table></figure>\n<p>函数的调用过程如下图所指示：</p>\n<p><img src=\"images/backtracking/bt7.jpg\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<h3 id=\"no.216-组合总数iii\">NO.216 组合总数III<a title=\"#no.216-组合总数iii\" href=\"#no.216-组合总数iii\"></a></h3>\n<ul>\n<li>\n<p>问题描述<br>\n给定一个数n和k，找出为n的k个数的所有组合，其中，每个数都在[1,9]之间</p>\n</li>\n<li>\n<p>问题分析<br>\n任然是一道用回溯法求解的问题，依旧可以用一棵树来表示问题的解空间，但是这棵树的深度由k决定，并且元素的值在[1,9]之间；<br>\n因此，递归的结束条件是当当前元素的值大于9（进入递归加一变为10），或是组合中的元素个数等于k；<br>\n一开始还是搞不懂要怎么递归下去，但是当我把解空间的树画出来，想到对于当前节点，下一个对象要么是其子节点，要么是其右兄弟节点；<br>\n因此，参数为(1,[])的函数内调用自身的参数为(2,[])，表示查看其右兄弟节点，或是(2,[1])，表示查看其第一个子节点，依次递归下去，一步步地就写出来了。</p>\n</li>\n<li>\n<p>求解代码</p>\n</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:  </span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">combinationSum3</span>(<span class=\"params\">self, k: <span class=\"built_in\">int</span>, n: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"type\">List</span>[<span class=\"type\">List</span>[<span class=\"built_in\">int</span>]]:  </span><br><span class=\"line\">        ans = []  </span><br><span class=\"line\">        <span class=\"keyword\">def</span> <span class=\"title function_\">trackback</span>(<span class=\"params\">i, l</span>):  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> i &gt; <span class=\"number\">10</span>:  </span><br><span class=\"line\">                <span class=\"keyword\">return</span>   </span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(l) == k:  </span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"built_in\">sum</span>(l) == n <span class=\"keyword\">and</span> l <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> ans:  </span><br><span class=\"line\">                    ans.append(l)  </span><br><span class=\"line\">                <span class=\"keyword\">return</span>  </span><br><span class=\"line\">            trackback(i+<span class=\"number\">1</span>, l+[i])  </span><br><span class=\"line\">            trackback(i+<span class=\"number\">1</span>, l)  </span><br><span class=\"line\">        trackback(<span class=\"number\">1</span>, [])  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans  </span><br></pre></td></tr></table></figure>\n<h2 id=\"三、另一种解题代码\">三、另一种解题代码<a title=\"#三、另一种解题代码\" href=\"#三、另一种解题代码\"></a></h2>\n<p>在Java刷题遇到回溯问题时，看了一下题解，发现了一个新的解题框架，就在这边也记录一下，就拿上面的<code>NO.39组合总数</code>为例，这道题也可以用下面的方法求解：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">combinationSum</span>(<span class=\"params\">candidates, target</span>):  </span><br><span class=\"line\">    ans = []  </span><br><span class=\"line\">    n = <span class=\"built_in\">len</span>(candidates)  </span><br><span class=\"line\">    candidates.sort()  </span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">backtrack</span>(<span class=\"params\">i, tmp_sum, tmp</span>):  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(tmp_sum&gt;target <span class=\"keyword\">or</span> i==n):  </span><br><span class=\"line\">            <span class=\"keyword\">return</span>  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(tmp_sum==target):  </span><br><span class=\"line\">            ans.append(tmp)  </span><br><span class=\"line\">            <span class=\"keyword\">return</span>   </span><br><span class=\"line\">        <span class=\"keyword\">for</span> start <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(i,n):  </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp_sum&gt;target):  </span><br><span class=\"line\">                <span class=\"keyword\">break</span>  </span><br><span class=\"line\">            backtrack(start,tmp_sum+candidates[start],tmp+[candidates[start]])  </span><br><span class=\"line\">    backtrack(<span class=\"number\">0</span>,<span class=\"number\">0</span>,[])  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans  </span><br><span class=\"line\">ans = combinationSum([<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>],<span class=\"number\">9</span>)  </span><br></pre></td></tr></table></figure>\n<p>这也是深度优先遍历，但是这种方法更好，因为上面的方法会遍历到重复的节点，因此耗时多一点，这种方法就不会，只要在backtrack函数里输出当前的tmp变量值就可以看到。</p>\n","prev":{"title":"Java算法笔记","link":"2019/11/05/blog/Java_leetcode_algorithm"},"next":{"title":"Python-动态规划算法","link":"2019/10/10/blog/dynamic-programming"},"plink":"https://qfzack.github.io/2019/10/10/blog/backtracking/","toc":[{"id":"一、算法概述","title":"一、算法概述","index":"1"},{"id":"二、算法实例","title":"二、算法实例","index":"2","children":[{"id":"no.22-括号生成","title":"NO.22 括号生成","index":"2.1"},{"id":"no.39-组合总数","title":"NO.39 组合总数","index":"2.2"},{"id":"no.40-组合总数ii","title":"NO.40 组合总数II","index":"2.3"},{"id":"no.77-列表的组合","title":"NO.77 列表的组合","index":"2.4"},{"id":"no.78-列表的子集","title":"NO.78 列表的子集","index":"2.5"},{"id":"n0.90-子集ii","title":"N0.90 子集II","index":"2.6"},{"id":"no.131-分割回文串","title":"NO.131 分割回文串","index":"2.7"},{"id":"no.216-组合总数iii","title":"NO.216 组合总数III","index":"2.8"}]},{"id":"三、另一种解题代码","title":"三、另一种解题代码","index":"3"}],"reading_time":"3058 words in 20 min"}